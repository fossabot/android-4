<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Leaflet Map</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.9.2/proj4.js"></script>
  <script src="https://unpkg.com/proj4leaflet@1.0.2/src/proj4leaflet.js"></script>
  <style>
    html, body, #map { height: 100%; margin: 0; }
    .leaflet-control-layers { font-size: 14px; }
    .fab { 
      position: absolute; 
      right: 16px; 
      bottom: 16px; 
      z-index: 1000; 
      background: #fff; 
      border: 1px solid #ccc; 
      border-radius: 50%; 
      width: 48px; 
      height: 48px; 
      display: flex; 
      align-items: center; 
      justify-content: center;
      cursor: pointer;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
      transition: all 0.2s ease;
    }
    .fab:hover {
      background: #f5f5f5;
      transform: scale(1.05);
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    }
    .fab:active {
      transform: scale(0.95);
    }
    .location-btn svg {
      color: #333;
    }
    .tile-error-tooltip {
      background: rgba(255, 87, 34, 0.9) !important;
      color: white !important;
      border: none !important;
      border-radius: 8px !important;
      padding: 8px 12px !important;
      font-size: 14px !important;
      font-weight: bold !important;
      box-shadow: 0 2px 8px rgba(0,0,0,0.3) !important;
      z-index: 1000 !important;
    }
    .tile-error-tooltip:before {
      display: none !important;
    }
    
    /* Custom Trigpointing Control Styles */
    .leaflet-trigpointing-control {
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.15);
      overflow: hidden;
      min-width: 200px;
    }
    
    .trigpointing-control-header {
      background: #2c3e50;
      color: white;
      padding: 12px 16px;
      cursor: pointer;
      font-weight: bold;
      font-size: 14px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .trigpointing-control-header:hover {
      background: #34495e;
    }
    
    .trigpointing-control-panel {
      max-height: 400px;
      overflow-y: auto;
    }
    
    .trigpointing-control-panel.collapsed {
      max-height: 0;
      overflow: hidden;
    }
    
    .control-section {
      border-bottom: 1px solid #ecf0f1;
    }
    
    .control-section:last-child {
      border-bottom: none;
    }
    
    .section-header {
      background: #ecf0f1;
      padding: 10px 16px;
      cursor: pointer;
      font-weight: 500;
      font-size: 13px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border: none;
      width: 100%;
      text-align: left;
    }
    
    .section-header:hover {
      background: #d5dbdb;
    }
    
    .section-content {
      padding: 8px 16px;
      background: white;
      max-height: 200px;
      overflow: hidden;
      transition: max-height 0.3s ease;
    }
    
    .section-content.collapsed {
      max-height: 0;
      padding: 0 16px;
    }
    
    .control-option {
      display: flex;
      align-items: center;
      padding: 6px 0;
      cursor: pointer;
    }
    
    .control-option:hover {
      background: #f8f9fa;
      margin: 0 -8px;
      padding: 6px 8px;
      border-radius: 4px;
    }
    
    .control-option input[type="radio"] {
      margin-right: 8px;
    }
    
    .control-option label {
      cursor: pointer;
      font-size: 13px;
      flex: 1;
    }
    
    .toggle-icon {
      font-size: 12px;
      transition: transform 0.2s ease;
    }
    
    .toggle-icon.expanded {
      transform: rotate(180deg);
    }
  </style>
</head>
<body>
  <div id="map"></div>
  <button class="fab location-btn" id="locbtn" title="My location">
    <svg viewBox="0 0 24 24" width="24" height="24" fill="currentColor">
      <!-- Standard location crosshairs icon -->
      <circle cx="12" cy="12" r="10" fill="none" stroke="currentColor" stroke-width="1"/>
      <circle cx="12" cy="12" r="6" fill="none" stroke="currentColor" stroke-width="1"/>
      <circle cx="12" cy="12" r="2" fill="currentColor"/>
      <path d="M12 2v4m0 12v4M2 12h4m12 0h4" stroke="currentColor" stroke-width="1"/>
    </svg>
  </button>
  <script>
    // Cache support detection and setup
    let cacheSupported = false;
    let cacheMode = 'none';
    
    // Try Service Worker first
    if ('serviceWorker' in navigator) {
      console.log('CACHE: Attempting Service Worker registration');
      navigator.serviceWorker.register('./sw.js')
        .then(registration => {
          console.log('CACHE: Service Worker registered successfully');
          cacheSupported = true;
          cacheMode = 'serviceworker';
        })
        .catch(error => {
          console.log('CACHE: Service Worker failed (expected in WebView):', error.message);
          initFallbackCache();
        });
    } else {
      console.log('CACHE: Service Workers not supported, using fallback');
      initFallbackCache();
    }
    
    // Fallback cache using WebView's built-in cache + localStorage
    function initFallbackCache() {
      cacheSupported = true;
      cacheMode = 'webview';
      console.log('CACHE: Using WebView fallback cache mode');
      
      // Enable aggressive caching via meta tags (already done in HTML head)
      // Store cache metadata in localStorage
      if (!localStorage.getItem('cache_init_time')) {
        localStorage.setItem('cache_init_time', Date.now().toString());
        localStorage.setItem('cached_tiles_count', '0');
      }
    }

    function getParam(name){ const url=new URL(window.location.href); return url.searchParams.get(name)||''; }
    const osKey = getParam('os_key');
    const initialStyle = getParam('initial_style') || 'OpenStreetMap';

    // Define OSGB CRS for 27700
    const osgb = new L.Proj.CRS(
      'EPSG:27700',
      '+proj=tmerc +lat_0=49 +lon_0=-2 +k=0.9996012717 +x_0=400000 +y_0=-100000 +ellps=airy +datum=OSGB36 +units=m +no_defs +towgs84=446.448,-125.157,542.06,0.1502,0.2470,0.8421,-20.4894',
      {
        resolutions: [896, 448, 224, 112, 56, 28, 14, 7, 3.5, 1.75, 0.875, 0.4375, 0.21875],
        origin: [-238375.0, 1376256.0],
        bounds: L.bounds([-238375.0, 0.0], [900000.0, 1376256.0])
      }
    );

    // Global variables for error tracking and cache monitoring
    let errorTooltip = null;
    let tileErrorCount = 0;
    let tileSuccessCount = 0;
    
    // Cache tile counter
    function updateTileCount() {
      if (cacheMode === 'webview') {
        const currentCount = parseInt(localStorage.getItem('cached_tiles_count') || '0');
        localStorage.setItem('cached_tiles_count', (currentCount + 1).toString());
      }
    }

    // Add tile error handling and visual feedback
    function addTileErrorHandling(layer, layerName, minZoom, maxZoom) {
      layer.on('tileerror', function(e) {
        tileErrorCount++;
        const zoom = map.getZoom();
        
        // Check if zoom is outside optimal range
        let zoomMessage = '';
        if (minZoom !== undefined && maxZoom !== undefined) {
          if (zoom < minZoom) {
            zoomMessage = ` (zoom too low, try ${minZoom}+)`;
          } else if (zoom > maxZoom) {
            zoomMessage = ` (zoom too high, try ${maxZoom} or lower)`;
          }
        }
        
        showErrorFeedback(`${layerName}: tiles unavailable at zoom ${zoom}${zoomMessage}`);
      });
      
      layer.on('tileload', function(e) {
        tileSuccessCount++;
        updateTileCount(); // Count tiles for cache tracking
        // Hide error feedback if tiles start loading successfully
        if (tileSuccessCount > 0 && errorTooltip) {
          hideErrorFeedback();
        }
      });
      
      layer.on('add', function() {
        // Reset counters when layer is added
        tileErrorCount = 0;
        tileSuccessCount = 0;
        hideErrorFeedback();
      });
    }

    function showErrorFeedback(message) {
      hideErrorFeedback(); // Remove any existing tooltip
      
      errorTooltip = L.tooltip({
        permanent: true,
        direction: 'center',
        className: 'tile-error-tooltip'
      })
      .setContent(`‚ö†Ô∏è ${message}`)
      .setLatLng(map.getCenter())
      .addTo(map);
      
      // Auto-hide after 5 seconds
      setTimeout(() => {
        if (errorTooltip && tileErrorCount > tileSuccessCount) {
          hideErrorFeedback();
        }
      }, 5000);
    }

    function hideErrorFeedback() {
      if (errorTooltip) {
        map.removeLayer(errorTooltip);
        errorTooltip = null;
      }
    }

    // Tile layer factories
    function createOSM() {
      const layer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '&copy; OpenStreetMap contributors'
      });
      addTileErrorHandling(layer, 'OpenStreetMap');
      return layer;
    }
    function createOSOutdoor() {
      const layer = L.tileLayer(`https://api.os.uk/maps/raster/v1/zxy/Outdoor_3857/{z}/{x}/{y}.png?key=${osKey}`, {
        attribution: '&copy; Ordnance Survey',
        noWrap: true
      });
      addTileErrorHandling(layer, 'OS Outdoor (3857)', 6, 19);
      return layer;
    }
    function createOSLeisure() {
      const layer = L.tileLayer(
        `https://api.os.uk/maps/raster/v1/zxy/Leisure_27700/{z}/{x}/{y}.png?key=${osKey}`,
        {
          tileSize: 256,
          noWrap: true,
          continuousWorld: false,
          attribution: '&copy; Ordnance Survey'
        }
      );
      addTileErrorHandling(layer, 'OS Leisure (27700)', 0, 13);
      return layer;
    }
    function createOSOutdoor27700() {
      const layer = L.tileLayer(
        `https://api.os.uk/maps/raster/v1/zxy/Outdoor_27700/{z}/{x}/{y}.png?key=${osKey}`,
        {
          tileSize: 256,
          noWrap: true,
          continuousWorld: false,
          attribution: '&copy; Ordnance Survey'
        }
      );
      addTileErrorHandling(layer, 'OS Outdoor (27700)', 0, 13);
      return layer;
    }

    let currentCRS = '3857';
    let currentLayerName = 'OpenStreetMap';
    let switchingCRS = false; // Flag to prevent recursive switching
    let pendingControlExpansion = false; // Flag to restore control state after CRS switch
    let pendingSectionStates = {}; // Object to store individual section states
    let map = L.map('map', { center: [54.0, -2.0], zoom: 7 });
    // layersControl removed - using custom control instead
    
    // Layer instances
    let osmLayer, outdoorLayer, leisureLayer, outdoor27700Layer;

    function initializeLayers() {
      osmLayer = createOSM();
      outdoorLayer = createOSOutdoor();
      leisureLayer = createOSLeisure();
      outdoor27700Layer = createOSOutdoor27700();
    }

    function initializeMap() {
      initializeLayers();
      
      // Determine initial layer and CRS based on preference
      let initialLayer = osmLayer;
      let initialCRS = L.CRS.EPSG3857;
      
      if (initialStyle === 'OS Outdoor (3857)') {
        initialLayer = outdoorLayer;
        initialCRS = L.CRS.EPSG3857;
      } else if (initialStyle === 'OS Outdoor (27700)') {
        initialLayer = outdoor27700Layer;
        initialCRS = osgb;
      } else if (initialStyle === 'OS Leisure (27700)') {
        initialLayer = leisureLayer;
        initialCRS = osgb;
      }
      
      // Recreate map with correct CRS if needed
      if (initialCRS !== L.CRS.EPSG3857) {
        map.remove();
        map = L.map('map', { crs: initialCRS, center: [54.0, -2.0], zoom: 7 });
        currentCRS = '27700';
        initializeLayers(); // Recreate layers for new map
      } else {
        currentCRS = '3857';
      }
      
      // Layer control removed - using custom control instead
      
      // Add scale control
      L.control.scale({
        position: 'bottomleft',
        metric: true,
        imperial: false,
        maxWidth: 200
      }).addTo(map);

      // Add custom trigpointing control
      L.control.trigpointingControl({
        position: 'topright'
      }).addTo(map);
      
      // Add initial layer after control is set up
      initialLayer.addTo(map);
      currentLayerName = initialStyle;
      
      // Setup custom control and markers
      setTimeout(() => {
        setupTrigpointingControl();
        loadControlPreferences();
        initializeMarkers();
        
        // Auto-center on GPS location when first visiting
        autoLocateOnFirstVisit();
      }, 100);
      
      map.on('baselayerchange', onBaseLayerChange);
    }

    function switchCRS(to27700, targetLayerName) {
      if (switchingCRS) return; // Prevent recursive calls
      switchingCRS = true;
      
      // Store current control state before CRS switch
      const panel = document.getElementById('trigpointing-panel');
      const controlWasExpanded = panel && !panel.classList.contains('collapsed');
      pendingControlExpansion = controlWasExpanded; // Store in global flag
      
      // Store individual section states
      pendingSectionStates = {};
      const sections = ['mapstyle', 'markercolor', 'trigpointtypes', 'filterfound'];
      sections.forEach(sectionName => {
        const sectionContent = document.getElementById(sectionName + '-content');
        if (sectionContent) {
          const isExpanded = !sectionContent.classList.contains('collapsed');
          pendingSectionStates[sectionName] = isExpanded;
          console.log(`Section ${sectionName} was expanded:`, isExpanded);
        }
      });
      
      console.log('Before CRS switch - Panel found:', !!panel);
      if (panel) {
        console.log('Before CRS switch - Panel classes:', panel.className);
        console.log('Before CRS switch - Has collapsed class:', panel.classList.contains('collapsed'));
      }
      console.log('Control was expanded before CRS switch:', controlWasExpanded);
      console.log('Set pendingControlExpansion to:', pendingControlExpansion);
      console.log('Stored section states:', pendingSectionStates);
      
      // Reset control setup flag since control will be recreated
      controlSetupDone = false;
      
      const center = map.getCenter();
      const zoom = map.getZoom();
      map.remove();
      
      // Convert zoom level to maintain similar field of view
      let targetZoom;
      if (to27700) {
        // Converting from 3857 to 27700
        // Get current resolution in meters per pixel
        const currentRes = map.options.crs.scale(zoom);
        // OSGB resolutions: [896, 448, 224, 112, 56, 28, 14, 7, 3.5, 1.75, 0.875, 0.4375, 0.21875]
        const osgbResolutions = [896, 448, 224, 112, 56, 28, 14, 7, 3.5, 1.75, 0.875, 0.4375, 0.21875];
        // Find closest matching resolution
        const webMercatorRes = 156543.03392804097 / Math.pow(2, zoom); // Web Mercator resolution at this zoom
        let bestMatch = 0;
        let bestDiff = Math.abs(osgbResolutions[0] - webMercatorRes);
        for (let i = 1; i < osgbResolutions.length; i++) {
          const diff = Math.abs(osgbResolutions[i] - webMercatorRes);
          if (diff < bestDiff) {
            bestDiff = diff;
            bestMatch = i;
          }
        }
        targetZoom = Math.max(0, Math.min(13, bestMatch));
      } else {
        // Converting from 27700 to 3857
        // Reverse: get OSGB resolution and find matching Web Mercator zoom
        const osgbResolutions = [896, 448, 224, 112, 56, 28, 14, 7, 3.5, 1.75, 0.875, 0.4375, 0.21875];
        const currentOsgbRes = osgbResolutions[Math.min(zoom, osgbResolutions.length - 1)];
        // Find matching Web Mercator zoom level
        targetZoom = Math.round(Math.log2(156543.03392804097 / currentOsgbRes));
        targetZoom = Math.max(0, Math.min(19, targetZoom));
      }
      
      const opts = to27700 ? { crs: osgb, center: center, zoom: targetZoom } : { center: center, zoom: targetZoom };
      map = L.map('map', opts);
      currentCRS = to27700 ? '27700' : '3857';
      
      // Recreate layers - layer control removed, using custom control instead
      initializeLayers();
      
      // Re-add scale control after CRS switch
      L.control.scale({
        position: 'bottomleft',
        metric: true,
        imperial: false,
        maxWidth: 200
      }).addTo(map);

      // Re-add custom trigpointing control after CRS switch
      L.control.trigpointingControl({
        position: 'topright'
      }).addTo(map);
      
      // Add the correct layer based on user selection
      if (targetLayerName === 'OS Leisure (27700)') {
        leisureLayer.addTo(map);
      } else if (targetLayerName === 'OS Outdoor (27700)') {
        outdoor27700Layer.addTo(map);
      } else if (targetLayerName === 'OS Outdoor (3857)') {
        outdoorLayer.addTo(map);
      } else {
        osmLayer.addTo(map);
      }
      
      currentLayerName = targetLayerName;
      
      // Reattach handlers
      document.getElementById('locbtn').onclick = locate;
      map.on('baselayerchange', onBaseLayerChange);
      
      // Reset error tracking for new map
      hideErrorFeedback();
      tileErrorCount = 0;
      tileSuccessCount = 0;
      
      // Setup custom control after CRS switch
      setTimeout(() => {
        setupTrigpointingControl();
        loadControlPreferences();
        initializeMarkers(); // Reinitialize markers after CRS switch
        
        // Check if control state was restored properly during creation
        console.log('Checking control state after CRS switch. PendingControlExpansion:', pendingControlExpansion);
        if (pendingControlExpansion) {
          const newPanel = document.getElementById('trigpointing-panel');
          const newToggle = document.getElementById('main-toggle');
          console.log('Found new panel:', !!newPanel, 'Found new toggle:', !!newToggle);
          
          if (newPanel) {
            console.log('Panel current classes after creation:', newPanel.className);
            console.log('Panel has collapsed class:', newPanel.classList.contains('collapsed'));
            
            // Verify the control was created in expanded state
            if (!newPanel.classList.contains('collapsed')) {
              console.log('Control was correctly created in expanded state');
            } else {
              console.log('Control was not created in expanded state, forcing expansion');
              newPanel.classList.remove('collapsed');
              if (newToggle) {
                newToggle.classList.add('expanded');
              }
            }
            pendingControlExpansion = false; // Clear the flag
          } else {
            console.log('Could not find new panel element');
          }
        } else {
          console.log('Control was not expanded before CRS switch, correctly created collapsed');
        }
        
        // Restore individual section states
        console.log('Restoring section states:', pendingSectionStates);
        Object.keys(pendingSectionStates).forEach(sectionName => {
          const shouldBeExpanded = pendingSectionStates[sectionName];
          const sectionContent = document.getElementById(sectionName + '-content');
          const sectionHeader = sectionContent?.previousElementSibling;
          const toggle = sectionHeader?.querySelector('.toggle-icon');
          
          if (sectionContent && shouldBeExpanded) {
            console.log(`Expanding section ${sectionName}`);
            sectionContent.classList.remove('collapsed');
            if (toggle) toggle.classList.add('expanded');
          } else if (sectionContent && !shouldBeExpanded) {
            console.log(`Keeping section ${sectionName} collapsed`);
            sectionContent.classList.add('collapsed');
            if (toggle) toggle.classList.remove('expanded');
          }
        });
        
        // Clear section states
        pendingSectionStates = {};
      }, 100);
      
      switchingCRS = false;
    }

    function onBaseLayerChange(e) {
      if (switchingCRS) return; // Ignore events during CRS switching
      
      const name = e.name || '';
      currentLayerName = name;
      
      // Save the new layer preference to Android
      if (typeof AndroidPrefs !== 'undefined') {
        AndroidPrefs.saveMapStyle(name);
      }
      
      const needs27700 = name.indexOf('27700') !== -1;
      const needsCRSSwitch = (needs27700 && currentCRS !== '27700') || (!needs27700 && currentCRS !== '3857');
      
      if (needsCRSSwitch) {
        switchCRS(needs27700, name);
      }
    }

    // updateLayerControlSelection function removed - no longer needed with custom control

    // Custom Trigpointing Control
    L.Control.TrigpointingControl = L.Control.extend({
      onAdd: function(map) {
        const container = L.DomUtil.create('div', 'leaflet-trigpointing-control leaflet-control');
        
        // Conditionally set initial collapsed state based on pending restoration
        const initialCollapsedClass = pendingControlExpansion ? '' : 'collapsed';
        const initialToggleClass = pendingControlExpansion ? 'expanded' : '';
        
        console.log('Creating control with pendingControlExpansion:', pendingControlExpansion);
        console.log('Initial collapsed class:', initialCollapsedClass);
        console.log('Initial toggle class:', initialToggleClass);
        
        container.innerHTML = `
          <div class="trigpointing-control-header" id="trigpointing-header">
            <span>üó∫Ô∏è Controls</span>
            <span class="toggle-icon ${initialToggleClass}" id="main-toggle">‚ñº</span>
          </div>
          <div class="trigpointing-control-panel ${initialCollapsedClass}" id="trigpointing-panel">
            
            <!-- Map Style Section -->
            <div class="control-section">
              <button class="section-header" data-section="mapstyle">
                <span>üó∫Ô∏è Map Style</span>
                <span class="toggle-icon">‚ñº</span>
              </button>
              <div class="section-content collapsed" id="mapstyle-content">
                <div class="control-option">
                  <input type="radio" name="mapstyle" value="OpenStreetMap" id="js-osm">
                  <label for="js-osm">OpenStreetMap</label>
                </div>
                <div class="control-option">
                  <input type="radio" name="mapstyle" value="OS Outdoor (3857)" id="js-outdoor3857">
                  <label for="js-outdoor3857">OS Outdoor (3857)</label>
                </div>
                <div class="control-option">
                  <input type="radio" name="mapstyle" value="OS Outdoor (27700)" id="js-outdoor27700">
                  <label for="js-outdoor27700">OS Outdoor (27700)</label>
                </div>
                <div class="control-option">
                  <input type="radio" name="mapstyle" value="OS Leisure (27700)" id="js-leisure27700">
                  <label for="js-leisure27700">OS Leisure (27700)</label>
                </div>
              </div>
            </div>
            
            <!-- Marker Color Section -->
            <div class="control-section">
              <button class="section-header" data-section="markercolor">
                <span>üé® Marker Colors</span>
                <span class="toggle-icon">‚ñº</span>
              </button>
              <div class="section-content collapsed" id="markercolor-content">
                <div class="control-option">
                  <input type="radio" name="markercolor" value="condition" id="js-condition">
                  <label for="js-condition">By Condition</label>
                </div>
                <div class="control-option">
                  <input type="radio" name="markercolor" value="logged" id="js-logged">
                  <label for="js-logged">By Logged Status</label>
                </div>
                <div class="control-option">
                  <input type="radio" name="markercolor" value="none" id="js-none">
                  <label for="js-none">None (Default)</label>
                </div>
              </div>
            </div>
            
            <!-- Trigpoint Types Section -->
            <div class="control-section">
              <button class="section-header" data-section="trigpointtypes">
                <span>üèîÔ∏è Trigpoint types</span>
                <span class="toggle-icon">‚ñº</span>
              </button>
              <div class="section-content collapsed" id="trigpointtypes-content">
                <div class="control-option">
                  <input type="radio" name="trigpointtype" value="all" id="js-types-all">
                  <label for="js-types-all">Show All</label>
                </div>
                <div class="control-option">
                  <input type="radio" name="trigpointtype" value="pillars" id="js-types-pillars">
                  <label for="js-types-pillars">Pillars Only</label>
                </div>
                <div class="control-option">
                  <input type="radio" name="trigpointtype" value="fbm" id="js-types-fbm">
                  <label for="js-types-fbm">Flush Bracket Marks</label>
                </div>
                <div class="control-option">
                  <input type="radio" name="trigpointtype" value="passive" id="js-types-passive">
                  <label for="js-types-passive">Passive Stations</label>
                </div>
                <div class="control-option">
                  <input type="radio" name="trigpointtype" value="intersected" id="js-types-intersected">
                  <label for="js-types-intersected">Intersected Stations</label>
                </div>
              </div>
            </div>
            
            <!-- Filter Found Section -->
            <div class="control-section">
              <button class="section-header" data-section="filterfound">
                <span>üîç Filter found</span>
                <span class="toggle-icon">‚ñº</span>
              </button>
              <div class="section-content collapsed" id="filterfound-content">
                <div class="control-option">
                  <input type="radio" name="filterfound" value="all" id="js-found-all">
                  <label for="js-found-all">All</label>
                </div>
                <div class="control-option">
                  <input type="radio" name="filterfound" value="logged" id="js-found-logged">
                  <label for="js-found-logged">Logged</label>
                </div>
                <div class="control-option">
                  <input type="radio" name="filterfound" value="notlogged" id="js-found-notlogged">
                  <label for="js-found-notlogged">Not Logged</label>
                </div>
                <div class="control-option">
                  <input type="radio" name="filterfound" value="marked" id="js-found-marked">
                  <label for="js-found-marked">Marked</label>
                </div>
                <div class="control-option">
                  <input type="radio" name="filterfound" value="unsynced" id="js-found-unsynced">
                  <label for="js-found-unsynced">Unsynced</label>
                </div>
              </div>
            </div>
            
          </div>
        `;
        
        // Prevent map interaction when clicking on control
        L.DomEvent.disableClickPropagation(container);
        L.DomEvent.disableScrollPropagation(container);
        
        return container;
      },
      
      onRemove: function(map) {
        // Cleanup if needed
      }
    });

    // Factory function
    L.control.trigpointingControl = function(opts) {
      return new L.Control.TrigpointingControl(opts);
    };

    // Control interaction handlers
    let controlSetupDone = false;
    function setupTrigpointingControl() {
      // Prevent duplicate event listener setup
      if (controlSetupDone) {
        console.log('Control setup already done, skipping duplicate setup');
        return;
      }
      
      // Main panel toggle
      document.getElementById('trigpointing-header').addEventListener('click', function() {
        const panel = document.getElementById('trigpointing-panel');
        const toggle = document.getElementById('main-toggle');
        
        panel.classList.toggle('collapsed');
        toggle.classList.toggle('expanded');
      });
      
      // Section toggles
      document.querySelectorAll('.section-header').forEach(header => {
        header.addEventListener('click', function() {
          const section = this.getAttribute('data-section');
          const content = document.getElementById(section + '-content');
          const toggle = this.querySelector('.toggle-icon');
          
          content.classList.toggle('collapsed');
          toggle.classList.toggle('expanded');
        });
      });
      
      controlSetupDone = true;
      
      // Check for pending control expansion (backup restoration)
      if (pendingControlExpansion) {
        console.log('Backup restoration: Checking if expansion needed');
        const panel = document.getElementById('trigpointing-panel');
        const toggle = document.getElementById('main-toggle');
        if (panel && panel.classList.contains('collapsed')) {
          console.log('Backup restoration: Panel still collapsed, forcing expansion');
          panel.classList.remove('collapsed');
          if (toggle) toggle.classList.add('expanded');
          console.log('Backup restoration: Control expanded successfully');
        } else {
          console.log('Backup restoration: Panel already expanded or not found');
        }
        pendingControlExpansion = false;
      }
      
      // Backup restoration for section states
      if (Object.keys(pendingSectionStates).length > 0) {
        console.log('Backup restoration: Restoring section states:', pendingSectionStates);
        Object.keys(pendingSectionStates).forEach(sectionName => {
          const shouldBeExpanded = pendingSectionStates[sectionName];
          const sectionContent = document.getElementById(sectionName + '-content');
          const sectionHeader = sectionContent?.previousElementSibling;
          const toggle = sectionHeader?.querySelector('.toggle-icon');
          
          if (sectionContent && shouldBeExpanded && sectionContent.classList.contains('collapsed')) {
            console.log(`Backup restoration: Expanding section ${sectionName}`);
            sectionContent.classList.remove('collapsed');
            if (toggle) toggle.classList.add('expanded');
          }
        });
        pendingSectionStates = {};
      }
      
      // Radio button handlers
      document.querySelectorAll('input[name="mapstyle"]').forEach(radio => {
        radio.addEventListener('change', function() {
          if (this.checked) {
            console.log('JS Control - Map style changed to:', this.value);
            // Switch map layer immediately
            switchMapToLayer(this.value);
          }
        });
      });
      
      document.querySelectorAll('input[name="markercolor"]').forEach(radio => {
        radio.addEventListener('change', function() {
          if (this.checked) {
            console.log('JS Control - Marker color changed to:', this.value);
            currentMarkerColor = this.value;
            localStorage.setItem('leaflet_marker_color', this.value);
            if (markersLayer) {
              currentBounds = null; // Force reload
              loadTrigpointMarkers();
            }
          }
        });
      });
      
      // Trigpoint type controls
      document.querySelectorAll('input[name="trigpointtype"]').forEach(radio => {
        radio.addEventListener('change', function() {
          if (this.checked) {
            console.log('JS Control - Trigpoint type changed to:', this.value);
            currentTrigpointType = this.value;
            localStorage.setItem('leaflet_trigpoint_type', this.value);
            if (markersLayer) {
              currentBounds = null; // Force reload
              loadTrigpointMarkers();
            }
          }
        });
      });
      
      // Filter found controls
      document.querySelectorAll('input[name="filterfound"]').forEach(radio => {
        radio.addEventListener('change', function() {
          if (this.checked) {
            console.log('JS Control - Filter found changed to:', this.value);
            currentFilterFound = this.value;
            localStorage.setItem('leaflet_filter_found', this.value);
            if (markersLayer) {
              currentBounds = null; // Force reload
              loadTrigpointMarkers();
            }
          }
        });
      });
    }

    // Functions that will be called from Android
    function switchToLayer(layerName) {
      console.log('Switching to layer:', layerName);
      
      // Update the JavaScript control radio buttons
      document.querySelectorAll('input[name="mapstyle"]').forEach(radio => {
        radio.checked = (radio.value === layerName);
      });
      
      // Actually switch the map layer
      switchMapToLayer(layerName);
    }

    function switchMapToLayer(layerName) {
      // Check if we need CRS switch
      const currentIs27700 = (currentCRS === '27700');
      const targetIs27700 = (layerName === 'OS Leisure (27700)' || layerName === 'OS Outdoor (27700)');
      
      if (currentIs27700 !== targetIs27700) {
        // Need CRS switch - use existing mechanism
        switchCRS(targetIs27700, layerName);
        return;
      }
      
      // Same CRS - just switch layers directly
      console.log('Switching layers within same CRS from', currentLayerName, 'to', layerName);
      
      // Remove current layer
      if (currentLayerName === 'OpenStreetMap' && map.hasLayer(osmLayer)) {
        map.removeLayer(osmLayer);
      } else if (currentLayerName === 'OS Outdoor (3857)' && map.hasLayer(outdoorLayer)) {
        map.removeLayer(outdoorLayer);
      } else if (currentLayerName === 'OS Outdoor (27700)' && map.hasLayer(outdoor27700Layer)) {
        map.removeLayer(outdoor27700Layer);
      } else if (currentLayerName === 'OS Leisure (27700)' && map.hasLayer(leisureLayer)) {
        map.removeLayer(leisureLayer);
      }
      
      // Add new layer
      if (layerName === 'OpenStreetMap') {
        osmLayer.addTo(map);
      } else if (layerName === 'OS Outdoor (3857)') {
        outdoorLayer.addTo(map);
      } else if (layerName === 'OS Outdoor (27700)') {
        outdoor27700Layer.addTo(map);
      } else if (layerName === 'OS Leisure (27700)') {
        leisureLayer.addTo(map);
      }
      
      // Update current layer name
      currentLayerName = layerName;
      
      // Trigger layer change event for preferences
      const layerChangeEvent = { name: layerName };
      onBaseLayerChange(layerChangeEvent);
    }

    function updateMarkerColors(colorScheme) {
      console.log('Updating marker colors:', colorScheme);
      
      // Update the JavaScript control radio buttons
      document.querySelectorAll('input[name="markercolor"]').forEach(radio => {
        radio.checked = (radio.value === colorScheme);
      });
      
      // Update current marker color and reload markers
      currentMarkerColor = colorScheme;
      localStorage.setItem('leaflet_marker_color', colorScheme);
      if (markersLayer) {
        currentBounds = null; // Force reload
        loadTrigpointMarkers();
      }
    }

    function updateTrigpointType(type) {
      console.log('Updating trigpoint type:', type);
      
      // Update the JavaScript control radio buttons if they exist
      document.querySelectorAll('input[name="trigpointtype"]').forEach(radio => {
        radio.checked = (radio.value === type);
      });
      
      // Update current type and reload markers
      currentTrigpointType = type;
      localStorage.setItem('leaflet_trigpoint_type', type);
      if (markersLayer) {
        currentBounds = null; // Force reload
        loadTrigpointMarkers();
      }
    }
    
    function updateFilterFound(found) {
      console.log('Updating filter found:', found);
      
      // Update the JavaScript control radio buttons if they exist
      document.querySelectorAll('input[name="filterfound"]').forEach(radio => {
        radio.checked = (radio.value === found);
      });
      
      // Update current found filter and reload markers
      currentFilterFound = found;
      localStorage.setItem('leaflet_filter_found', found);
      if (markersLayer) {
        currentBounds = null; // Force reload
        loadTrigpointMarkers();
      }
    }

    // Load preferences and set initial control states
    function loadControlPreferences() {
      // Set map style selection
      const currentMapStyle = currentLayerName || 'OpenStreetMap';
      document.querySelectorAll('input[name="mapstyle"]').forEach(radio => {
        radio.checked = (radio.value === currentMapStyle);
      });
      
      // Set other preferences from localStorage or defaults and update globals
      const markerColor = localStorage.getItem('leaflet_marker_color') || 'none';
      currentMarkerColor = markerColor;
      document.querySelectorAll('input[name="markercolor"]').forEach(radio => {
        radio.checked = (radio.value === markerColor);
      });
      
      const trigpointType = localStorage.getItem('leaflet_trigpoint_type') || 'all';
      currentTrigpointType = trigpointType;
      document.querySelectorAll('input[name="trigpointtype"]').forEach(radio => {
        radio.checked = (radio.value === trigpointType);
      });
      
      const filterFound = localStorage.getItem('leaflet_filter_found') || 'all';
      currentFilterFound = filterFound;
      document.querySelectorAll('input[name="filterfound"]').forEach(radio => {
        radio.checked = (radio.value === filterFound);
      });
    }

    // Trigpoint marker management
    let markersLayer = null;
    let currentBounds = null;
    let currentMarkerColor = 'none';
    let currentTrigpointType = 'all';
    let currentFilterFound = 'all';

    // Service Worker communication
    async function sendServiceWorkerMessage(type, data = {}) {
      console.log('SW MESSAGE: Attempting to send message type:', type);
      
      if (!navigator.serviceWorker) {
        console.error('SW MESSAGE: Service Worker not supported');
        throw new Error('Service Worker not supported');
      }
      
      // Wait for service worker to be ready
      await navigator.serviceWorker.ready;
      
      if (!navigator.serviceWorker.controller) {
        console.error('SW MESSAGE: Service Worker controller not available');
        throw new Error('Service Worker not controlling page - try refreshing');
      }
      
      console.log('SW MESSAGE: Service Worker ready, sending message');
      
      return new Promise((resolve, reject) => {
        const messageChannel = new MessageChannel();
        
        messageChannel.port1.onmessage = (event) => {
          console.log('SW MESSAGE: Received response:', event.data);
          if (event.data.success) {
            resolve(event.data);
          } else {
            reject(new Error(event.data.error));
          }
        };
        
        navigator.serviceWorker.controller.postMessage(
          { type, data },
          [messageChannel.port2]
        );
      });
    }

    // Cache management functions
    async function getCacheStatus() {
      console.log('CACHE: Getting cache status, mode:', cacheMode);
      
      if (cacheMode === 'serviceworker') {
        try {
          const response = await sendServiceWorkerMessage('CACHE_STATUS');
          return response.status;
        } catch (error) {
          console.error('CACHE: Service Worker cache status failed:', error);
          return { error: 'Service Worker error: ' + error.message };
        }
      } else if (cacheMode === 'webview') {
        // WebView fallback - estimate cache from localStorage and performance
        const initTime = localStorage.getItem('cache_init_time');
        const estimatedTiles = localStorage.getItem('cached_tiles_count') || '0';
        const daysSinceInit = initTime ? Math.floor((Date.now() - parseInt(initTime)) / (1000 * 60 * 60 * 24)) : 0;
        
        return {
          mode: 'WebView Cache',
          tileCount: parseInt(estimatedTiles),
          totalSize: parseInt(estimatedTiles) * 15000, // Estimate 15KB per tile
          usagePercent: Math.min(Math.floor(parseInt(estimatedTiles) / 100), 100), // Estimate %
          cacheAge: daysSinceInit + ' days',
          note: 'Using WebView built-in cache (tiles persist until app cache cleared)'
        };
      } else {
        return { error: 'Cache not available' };
      }
    }

    async function clearTileCache() {
      console.log('CACHE: Clearing cache, mode:', cacheMode);
      
      if (cacheMode === 'serviceworker') {
        try {
          await sendServiceWorkerMessage('CLEAR_CACHE');
          console.log('CACHE: Service Worker cache cleared');
          return true;
        } catch (error) {
          console.error('CACHE: Failed to clear SW cache:', error);
          return false;
        }
      } else if (cacheMode === 'webview') {
        // WebView fallback - clear localStorage and prompt for app cache clear
        localStorage.setItem('cached_tiles_count', '0');
        localStorage.setItem('cache_init_time', Date.now().toString());
        console.log('CACHE: WebView cache metadata cleared');
        
        // Note: Can't programmatically clear WebView cache from JavaScript
        // This requires Android code or user action
        return { 
          partial: true, 
          message: 'Cache metadata cleared. To fully clear tiles, go to Android Settings > Apps > TrigpointingUK > Storage > Clear Cache' 
        };
      } else {
        return false;
      }
    }

    async function downloadBulkTiles(zipUrl, options = {}) {
      console.log('CACHE: Bulk download request, mode:', cacheMode);
      
      if (cacheMode === 'serviceworker') {
        try {
          const response = await sendServiceWorkerMessage('BULK_DOWNLOAD', { 
            url: zipUrl, 
            options 
          });
          console.log('CACHE: Service Worker bulk download completed');
          return response.result;
        } catch (error) {
          console.error('CACHE: Bulk download failed:', error);
          throw error;
        }
      } else if (cacheMode === 'webview') {
        // WebView fallback - can't directly bulk download to WebView cache
        // But we can pre-load tiles by making requests
        throw new Error('Bulk download not supported in WebView mode. Tiles will cache automatically as you browse the map.');
      } else {
        throw new Error('Cache not available');
      }
    }

    function initializeMarkers() {
      console.log('MARKER DEBUG: initializeMarkers() called');
      console.log('MARKER DEBUG: Current CRS:', currentCRS);
      console.log('MARKER DEBUG: Map exists:', !!map);
      
      // Create markers layer group
      markersLayer = L.layerGroup().addTo(map);
      console.log('MARKER DEBUG: Created markersLayer and added to map');
      
      // Load initial markers
      loadTrigpointMarkers();
      
      // Update markers when map moves
      map.on('moveend', () => {
        loadTrigpointMarkers();
      });
      
      map.on('zoomend', () => {
        loadTrigpointMarkers();
      });
    }

    function loadTrigpointMarkers() {
      console.log('MARKER DEBUG: loadTrigpointMarkers() called');
      console.log('MARKER DEBUG: markersLayer exists:', !!markersLayer);
      
      const bounds = map.getBounds();
      const zoom = map.getZoom();
      
      // Marker count is now user-configurable, so no need for zoom-based clearing
      
      // Check if we need to reload (bounds changed significantly)
      if (currentBounds && bounds.contains(currentBounds)) {
        console.log('Markers: No reload needed, current view within cached bounds');
        return;
      }
      
      console.log('Loading trigpoint markers for bounds:', bounds);
      console.log(`Map CRS: ${currentCRS}, Zoom: ${map.getZoom()}`);
      
      // Expand bounds for efficient loading
      const expandedBounds = bounds.pad(0.5); // 50% expansion
      currentBounds = expandedBounds;
      
      console.log(`Querying trigpoints: S=${expandedBounds.getSouth()}, W=${expandedBounds.getWest()}, N=${expandedBounds.getNorth()}, E=${expandedBounds.getEast()}`);
      
      // Call Android to get trigpoint data
      AndroidPrefs.getTrigpointData(
        expandedBounds.getSouth(),
        expandedBounds.getWest(), 
        expandedBounds.getNorth(),
        expandedBounds.getEast(),
        currentTrigpointType,
        currentFilterFound,
        currentMarkerColor
      );
    }

    function displayTrigpointMarkers(trigpointsJson) {
      console.log('Displaying trigpoint markers:', trigpointsJson);
      
      try {
        const trigpoints = JSON.parse(trigpointsJson);
        
        // Clear existing markers
        markersLayer.clearLayers();
        
        trigpoints.forEach(trig => {
          // Use standard lat/lon - Leaflet CRS should handle transformation automatically
          const coords = [trig.lat, trig.lon];
          
          console.log(`Creating marker for ${trig.name} at [${trig.lat}, ${trig.lon}] in CRS: ${currentCRS}`);
          console.log(`Current map bounds:`, map.getBounds());
          console.log(`Map center:`, map.getCenter());
          
          const marker = L.marker(coords, {
            icon: createTrigIcon(trig)
          });
          
          // Add popup with basic info
          marker.bindPopup(`
            <b>${trig.name}</b><br>
            Type: ${trig.type}<br>
            Condition: ${trig.condition}<br>
            <a href="#" onclick="AndroidPrefs.openTrigDetails(${trig.id})">View Details</a>
          `);
          
          // Add click handler for details
          marker.on('click', () => {
            AndroidPrefs.openTrigDetails(trig.id);
          });
          
          markersLayer.addLayer(marker);
        });
        
        console.log(`Added ${trigpoints.length} markers to map`);
        
      } catch (error) {
        console.error('Error parsing trigpoint data:', error);
      }
    }

    function createTrigIcon(trig) {
      // Determine icon based on type and coloring scheme
      let iconClass = 'trig-icon';
      let color = 'green'; // default
      
      // Apply coloring scheme
      if (currentMarkerColor === 'condition') {
        color = getConditionColor(trig.condition);
      } else if (currentMarkerColor === 'logged') {
        color = getLoggedColor(trig.logged);
      }
      
      // Get type-specific icon
      const iconUrl = getTrigIconUrl(trig.type, color, trig.flagged);
      console.log(`Creating icon for ${trig.name}: type=${trig.type}, color=${color}, iconUrl=${iconUrl}`);
      
      return L.icon({
        iconUrl: iconUrl,
        iconSize: [20, 20],
        iconAnchor: [10, 10],
        popupAnchor: [0, -10]
      });
    }

    function getConditionColor(condition) {
      // Match OSMdroid MapIcon color logic using single-letter codes
      switch (condition) {
        case 'U': // Unknown
        case 'Z': // Condition not logged 
        case '-': // Trig not logged
          return 'grey';
        case 'G': // Good
        case 'S': // Slightly damaged
        case 'C': // Converted
        case 'D': // Damaged
        case 'T': // Toppled
        case 'M': // Moved
        case 'R': // Remains
          return 'green';
        case 'V': // Visible (unreachable but visible)
          return 'yellow';
        case 'Q': // Possibly missing
        case 'X': // Missing/destroyed
        case 'P': // Inaccessible
        case 'N': // Couldn't find
          return 'red';
        default:
          return 'grey';
      }
    }

    function getLoggedColor(logged) {
      // Use logged status codes
      if (logged === '-') { // TRIGNOTLOGGED
        return 'grey';
      } else {
        return 'green';
      }
    }

    function getTrigIconUrl(type, color, flagged) {
      // Map database type codes to icon type names
      const typeMap = {
        'PI': 'pillar',
        'FB': 'fbm', 
        'IN': 'intersected'
      };
      
      // Default to passive for any unknown types
      const iconType = typeMap[type] || 'passive';
      
      // Build icon path based on type, color, and highlight state
      const highlight = flagged ? '_h' : '';
      const iconName = `mapicon_${iconType}_${color}${highlight}.png`;
      
      // Use relative path from current leaflet directory
      return `icons/${iconName}`;
    }

    initializeMap();

    function autoLocateOnFirstVisit() {
      // Check if we should auto-center on first visit
      const hasAutoLocated = sessionStorage.getItem('leaflet_auto_located');
      if (!hasAutoLocated) {
        console.log('First visit to map - attempting auto-location');
        sessionStorage.setItem('leaflet_auto_located', 'true');
        locate();
      }
    }

    function locate(){
      if (!navigator.geolocation) { 
        console.log('Geolocation not supported'); 
        return; 
      }
      
      console.log('Getting current location...');
      navigator.geolocation.getCurrentPosition(function(pos){
        const lat = pos.coords.latitude, lon = pos.coords.longitude;
        console.log(`Located at: ${lat}, ${lon}`);
        
        // Adjust zoom level based on current projection
        let zoom;
        if (currentCRS === '27700') {
          // EPSG:27700 needs lower zoom numbers for similar field of view
          zoom = 7; // Roughly equivalent to zoom 14 in Web Mercator
        } else {
          // EPSG:3857 Web Mercator  
          zoom = 14;
        }
        
        console.log(`Setting view with zoom ${zoom} for CRS ${currentCRS}`);
        map.setView([lat, lon], zoom);
        
        // Optional: Add a temporary marker to show current location
        // This could be enhanced to show accuracy circle
      }, function(err){
        console.log('Error getting location: ' + err.message);
        // Don't show alert for auto-location failures to avoid disrupting UX
      }, {
        enableHighAccuracy: true,
        timeout: 10000,
        maximumAge: 300000 // 5 minutes
      });
    }
    document.getElementById('locbtn').onclick = locate;
  </script>
</body>
</html>


