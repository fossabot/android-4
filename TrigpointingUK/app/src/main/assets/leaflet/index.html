<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Leaflet Map</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.9.2/proj4.js"></script>
  <script src="https://unpkg.com/proj4leaflet@1.0.2/src/proj4leaflet.js"></script>
  <style>
    html, body, #map { height: 100%; margin: 0; }
    .leaflet-control-layers { font-size: 14px; }
    .fab { 
      position: absolute; 
      right: 16px; 
      bottom: 16px; 
      z-index: 1000; 
      background: #fff; 
      border: 1px solid #ccc; 
      border-radius: 50%; 
      width: 48px; 
      height: 48px; 
      display: flex; 
      align-items: center; 
      justify-content: center;
      cursor: pointer;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
      transition: all 0.2s ease;
    }
    .fab:hover {
      background: #f5f5f5;
      transform: scale(1.05);
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    }
    .fab:active {
      transform: scale(0.95);
    }
    .location-btn svg {
      color: #333;
    }
    .tile-error-tooltip {
      background: rgba(255, 87, 34, 0.9) !important;
      color: white !important;
      border: none !important;
      border-radius: 8px !important;
      padding: 8px 12px !important;
      font-size: 14px !important;
      font-weight: bold !important;
      box-shadow: 0 2px 8px rgba(0,0,0,0.3) !important;
      z-index: 1000 !important;
    }
    .tile-error-tooltip:before {
      display: none !important;
    }
    
    /* Custom Trigpointing Control Styles */
    .leaflet-trigpointing-control {
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.15);
      overflow: hidden;
      min-width: 200px;
    }
    
    .trigpointing-control-header {
      background: #2c3e50;
      color: white;
      padding: 12px 16px;
      cursor: pointer;
      font-weight: bold;
      font-size: 14px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .trigpointing-control-header:hover {
      background: #34495e;
    }
    
    .trigpointing-control-panel {
      max-height: 400px;
      overflow-y: auto;
    }
    
    .trigpointing-control-panel.collapsed {
      max-height: 0;
      overflow: hidden;
    }
    
    .control-section {
      border-bottom: 1px solid #ecf0f1;
    }
    
    .control-section:last-child {
      border-bottom: none;
    }
    
    .section-header {
      background: #ecf0f1;
      padding: 10px 16px;
      cursor: pointer;
      font-weight: 500;
      font-size: 13px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border: none;
      width: 100%;
      text-align: left;
    }
    
    .section-header:hover {
      background: #d5dbdb;
    }
    
    .section-content {
      padding: 8px 16px;
      background: white;
      max-height: 200px;
      overflow: hidden;
      transition: max-height 0.3s ease;
    }
    
    .section-content.collapsed {
      max-height: 0;
      padding: 0 16px;
    }
    
    .control-option {
      display: flex;
      align-items: center;
      padding: 6px 0;
      cursor: pointer;
    }
    
    .control-option:hover {
      background: #f8f9fa;
      margin: 0 -8px;
      padding: 6px 8px;
      border-radius: 4px;
    }
    
    .control-option input[type="radio"] {
      margin-right: 8px;
    }
    
    .control-option label {
      cursor: pointer;
      font-size: 13px;
      flex: 1;
    }
    
    .toggle-icon {
      font-size: 12px;
      transition: transform 0.2s ease;
    }
    
    .toggle-icon.expanded {
      transform: rotate(180deg);
    }
    .location-marker {
      background: transparent !important;
      border: none !important;
    }
    
    /* Zoom Level Display */
    .zoom-level-display {
      position: absolute;
      top: 78px; /* Position below the zoom controls with small gap */
      left: 10px; /* Align with zoom controls */
      background: rgba(255, 255, 255, 0.8);
      border: 1px solid #ccc;
      border-radius: 4px;
      padding: 4px 8px;
      font-size: 11px;
      color: #555;
      font-family: "Helvetica Neue", Arial, Helvetica, sans-serif;
      z-index: 1000;
      box-shadow: 0 1px 3px rgba(0,0,0,0.2);
      pointer-events: none; /* Allow clicks to pass through */
    }
  </style>
</head>
<body>
  <div id="map"></div>
  <div id="zoom-level-display" class="zoom-level-display">7</div>
  <button class="fab location-btn" id="locbtn" title="My location">
    <svg viewBox="0 0 24 24" width="24" height="24" fill="currentColor">
      <!-- Standard location crosshairs icon -->
      <circle cx="12" cy="12" r="10" fill="none" stroke="currentColor" stroke-width="1"/>
      <circle cx="12" cy="12" r="6" fill="none" stroke="currentColor" stroke-width="1"/>
      <circle cx="12" cy="12" r="2" fill="currentColor"/>
      <path d="M12 2v4m0 12v4M2 12h4m12 0h4" stroke="currentColor" stroke-width="1"/>
    </svg>
  </button>
  <script>
    /*
    // Cache support detection and setup
    let cacheSupported = false;
    let cacheMode = 'none';
    
    // Try Service Worker first
    if ('serviceWorker' in navigator) {
      console.log('CACHE: Attempting Service Worker registration');
      navigator.serviceWorker.register('./sw.js')
        .then(registration => {
          console.log('CACHE: Service Worker registered successfully');
          cacheSupported = true;
          cacheMode = 'serviceworker';
        })
        .catch(error => {
          console.log('CACHE: Service Worker failed (expected in WebView):', error.message);
          initFallbackCache();
        });
    } else {
      console.log('CACHE: Service Workers not supported, using fallback');
      initFallbackCache();
    }
    
    // Fallback cache using WebView's built-in cache + localStorage
    function initFallbackCache() {
      cacheSupported = true;
      cacheMode = 'webview';
      console.log('CACHE: Using WebView fallback cache mode');
      
      // Enable aggressive caching via meta tags (already done in HTML head)
      // Store cache metadata in localStorage
      if (!localStorage.getItem('cache_init_time')) {
        localStorage.setItem('cache_init_time', Date.now().toString());
        localStorage.setItem('cached_tiles_count', '0');
      }
    }
    */

    function getParam(name) {
      // Backward compatible URL parameter parsing for older Android WebView versions
      // This replaces new URL() constructor which wasn't available in older Chrome/WebView
      var search = window.location.search;
      if (search.length <= 1) return '';
      
      var urlParams = search.substring(1).split('&');
      for (var i = 0; i < urlParams.length; i++) {
        var param = urlParams[i].split('=');
        var key = param[0];
        var value = param[1] || '';
        if (key === name) {
          try {
            return decodeURIComponent(value);
          } catch (e) {
            return value; // fallback if decoding fails
          }
        }
      }
      return '';
    }
    const osKey = getParam('os_key');
    const rawInitialStyle = getParam('initial_style') || 'OpenStreetMap';
    // URL decode the initial style parameter
    const initialStyle = decodeURIComponent(rawInitialStyle.replace(/\+/g, ' '));
    console.log('JavaScript received initial_style parameter (raw):', rawInitialStyle);
    console.log('JavaScript using initialStyle (decoded):', initialStyle);

    // Define OSGB CRS for 27700
    const osgb = new L.Proj.CRS(
      'EPSG:27700',
      '+proj=tmerc +lat_0=49 +lon_0=-2 +k=0.9996012717 +x_0=400000 +y_0=-100000 +ellps=airy +datum=OSGB36 +units=m +no_defs +towgs84=446.448,-125.157,542.06,0.1502,0.2470,0.8421,-20.4894',
      {
        resolutions: [896, 448, 224, 112, 56, 28, 14, 7, 3.5, 1.75, 0.875, 0.4375, 0.21875],
        origin: [-238375.0, 1376256.0],
        bounds: L.bounds([-238375.0, 0.0], [900000.0, 1376256.0])
      }
    );

    // Global variables for error tracking and cache monitoring
    let errorTooltip = null;
    let tileErrorCount = 0;
    let tileSuccessCount = 0;
    
    /*
    // Cache tile counter
    function updateTileCount() {
      if (cacheMode === 'webview') {
        const currentCount = parseInt(localStorage.getItem('cached_tiles_count') || '0');
        localStorage.setItem('cached_tiles_count', (currentCount + 1).toString());
      }
    }
    */

    // Add tile error handling and visual feedback
    function addTileErrorHandling(layer, layerName, minZoom, maxZoom) {
      layer.on('tileerror', function(e) {
        tileErrorCount++;
        const zoom = map.getZoom();
        
        // Check if this is an OS layer and the API key is missing/empty
        const isOSLayer = layerName.includes('OS ');
        const isApiKeyMissing = !osKey || osKey.trim() === '';
        
        if (isOSLayer && isApiKeyMissing) {
          // Show helpful message about missing API key
          showErrorFeedback(`${layerName}: API key required. Please set your Ordnance Survey API key in Settings ‚Üí Map Settings`);
          return;
        }
        
        // Check if zoom is outside optimal range
        let zoomMessage = '';
        if (minZoom !== undefined && maxZoom !== undefined) {
          if (zoom < minZoom) {
            zoomMessage = ` (zoom too low, try ${minZoom}+)`;
          } else if (zoom > maxZoom) {
            zoomMessage = ` (zoom too high, try ${maxZoom} or lower)`;
          }
        }
        
        showErrorFeedback(`${layerName}: tiles unavailable at zoom ${zoom}${zoomMessage}`);
      });
      
      layer.on('tileload', function(e) {
        tileSuccessCount++;
        // updateTileCount(); // Count tiles for cache tracking
        // Hide error feedback if tiles start loading successfully
        if (tileSuccessCount > 0 && errorTooltip) {
          hideErrorFeedback();
        }
      });
      
      layer.on('add', function() {
        // Reset counters when layer is added
        tileErrorCount = 0;
        tileSuccessCount = 0;
        hideErrorFeedback();
      });
    }

    function showErrorFeedback(message) {
      hideErrorFeedback(); // Remove any existing tooltip
      
      errorTooltip = L.tooltip({
        permanent: true,
        direction: 'center',
        className: 'tile-error-tooltip'
      })
      .setContent(`‚ö†Ô∏è ${message}`)
      .setLatLng(map.getCenter())
      .addTo(map);
      
      // Auto-hide after 5 seconds
      setTimeout(() => {
        if (errorTooltip && tileErrorCount > tileSuccessCount) {
          hideErrorFeedback();
        }
      }, 5000);
    }

    function hideErrorFeedback() {
      if (errorTooltip) {
        map.removeLayer(errorTooltip);
        errorTooltip = null;
      }
    }

    // Tile layer factories
    function createOSM() {
      const layer = L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '&copy; OpenStreetMap contributors',
        minZoom: 0,
        maxZoom: 19
      });
      addTileErrorHandling(layer, 'OpenStreetMap', 0, 19);
      return layer;
    }
    
    function createESRIWorldImagery() {
      const layer = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
        attribution: 'Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community',
        minZoom: 0,
        maxZoom: 18
      });
      addTileErrorHandling(layer, 'ESRI.WorldImagery', 0, 18);
      return layer;
    }
    function createOSLeisure() {
      const layer = L.tileLayer(
        `https://api.os.uk/maps/raster/v1/zxy/Leisure_27700/{z}/{x}/{y}.png?key=${osKey}`,
        {
          tileSize: 256,
          noWrap: true,
          continuousWorld: false,
          attribution: '&copy; Ordnance Survey',
          minZoom: 0,
          maxZoom: 9
        }
      );
      addTileErrorHandling(layer, 'OS Leisure', 0, 9);
      return layer;
    }
    function createOSOutdoor3857() {
      const layer = L.tileLayer(
        `https://api.os.uk/maps/raster/v1/zxy/Outdoor_3857/{z}/{x}/{y}.png?key=${osKey}`,
        {
          attribution: '&copy; Ordnance Survey',
          minZoom: 0,
          maxZoom: 20
        }
      );
      addTileErrorHandling(layer, 'OS Outdoor', 0, 20);
      return layer;
    }

    let currentCRS = '3857';
    let currentLayerName = 'OpenStreetMap';
    let switchingCRS = false; // Flag to prevent recursive switching
    let pendingControlExpansion = false; // Flag to restore control state after CRS switch
    let pendingSectionStates = {}; // Object to store individual section states
    
    function getInitialMapView(forCRS = '3857') {
      // Try to get cached location from previous session
      const cachedLocation = localStorage.getItem('leaflet_last_location');
      if (cachedLocation) {
        try {
          const location = JSON.parse(cachedLocation);
          const age = Date.now() - location.timestamp;
          // Use cached location if less than 24 hours old
          if (age < 24 * 60 * 60 * 1000) {
            console.log('Using cached location for initial view:', location);
            const zoom = forCRS === '27700' ? 7 : 14; // Adjust zoom for projection
            return {
              center: [location.lat, location.lon],
              zoom: zoom
            };
          }
        } catch (e) {
          console.log('Invalid cached location data');
        }
      }
      
      // Fall back to UK centre
      console.log('No cached location, using UK centre');
      return {
        center: [54.0, -2.0],
        zoom: 7
      };
    }

    const initialView = getInitialMapView();
    let map = L.map('map', { center: initialView.center, zoom: initialView.zoom });
    // layersControl removed - using custom control instead
    
    // Layer instances
    let osmLayer, esriLayer, leisureLayer, outdoorLayer;

    function initialiseLayers() {
      osmLayer = createOSM();
      esriLayer = createESRIWorldImagery();
      leisureLayer = createOSLeisure();
      outdoorLayer = createOSOutdoor3857();
    }

    function initialiseMap() {
      initialiseLayers();
      
      // Session management: use session style if it exists, otherwise use preference and save to session
      let sessionStyle = sessionStorage.getItem('leaflet_session_map_style');
      let styleToUse;
      
      if (sessionStyle) {
        // We have a session style - use it (this is a return visit to the map)
        styleToUse = sessionStyle;
        console.log('Using existing session style:', sessionStyle);
      } else {
        // No session style - this is the first map visit this session
        // Use the user's preference and save it as the session style
        styleToUse = initialStyle;
        sessionStorage.setItem('leaflet_session_map_style', initialStyle);
        console.log('First map visit - using preference and saving to session:', initialStyle);
      }
      
      // Convert preference value to JavaScript layer name
      const jsInitialStyle = convertPreferenceToJSLayer(styleToUse);
      console.log('Converting style:', styleToUse, '‚Üí', jsInitialStyle);
      let initialLayer = osmLayer;
      let initialCRS = L.CRS.EPSG3857;
      
      if (jsInitialStyle === 'ESRI.WorldImagery') {
        initialLayer = esriLayer;
        initialCRS = L.CRS.EPSG3857;
      } else if (jsInitialStyle === 'OS Outdoor') {
        initialLayer = outdoorLayer;
        initialCRS = L.CRS.EPSG3857;
      } else if (jsInitialStyle === 'OS Leisure') {
        initialLayer = leisureLayer;
        initialCRS = osgb;
      }
      
      // Recreate map with correct CRS if needed
      if (initialCRS !== L.CRS.EPSG3857) {
        map.remove();
        const view27700 = getInitialMapView('27700');
        map = L.map('map', { crs: initialCRS, center: view27700.center, zoom: view27700.zoom });
        currentCRS = '27700';
        initialiseLayers(); // Recreate layers for new map
      } else {
        currentCRS = '3857';
      }
      
      // Layer control removed - using custom control instead
      
      // Add scale control
      L.control.scale({
        position: 'bottomleft',
        metric: true,
        imperial: false,
        maxWidth: 200
      }).addTo(map);

      // Add custom trigpointing control
      L.control.trigpointingControl({
        position: 'topright'
      }).addTo(map);
      
      // Add initial layer after control is set up
      console.log('Adding initial layer to map:', jsInitialStyle);
      initialLayer.addTo(map);
      currentLayerName = jsInitialStyle;
      console.log('Set currentLayerName to:', currentLayerName);
      
      // Setup custom control and markers
      setTimeout(() => {
        setupTrigpointingControl();
        loadControlPreferences();
        initialiseMarkers();
        
        // Initialize zoom level display
        updateZoomLevelDisplay();
        
        // Auto-centre on GPS location when first visiting and start location tracking by default
        autoLocateOnFirstVisit();
      }, 100);
      
      map.on('baselayerchange', onBaseLayerChange);
    }

    function switchCRS(to27700, targetLayerName) {
      if (switchingCRS) return; // Prevent recursive calls
      switchingCRS = true;
      
      // Save the session style when switching CRS
      const preferenceValue = convertJSLayerToPreference(targetLayerName);
      sessionStorage.setItem('leaflet_session_map_style', preferenceValue);
      console.log('Saved session map style during CRS switch:', preferenceValue);
      
      // Store current control state before CRS switch
      const panel = document.getElementById('trigpointing-panel');
      const controlWasExpanded = panel && !panel.classList.contains('collapsed');
      pendingControlExpansion = controlWasExpanded; // Store in global flag
      
      // Store individual section states
      pendingSectionStates = {};
      const sections = ['mapstyle', 'markercolor', 'trigpointtypes', 'filterfound'];
      sections.forEach(sectionName => {
        const sectionContent = document.getElementById(sectionName + '-content');
        if (sectionContent) {
          const isExpanded = !sectionContent.classList.contains('collapsed');
          pendingSectionStates[sectionName] = isExpanded;
          console.log(`Section ${sectionName} was expanded:`, isExpanded);
        }
      });
      
      console.log('Before CRS switch - Panel found:', !!panel);
      if (panel) {
        console.log('Before CRS switch - Panel classes:', panel.className);
        console.log('Before CRS switch - Has collapsed class:', panel.classList.contains('collapsed'));
      }
      console.log('Control was expanded before CRS switch:', controlWasExpanded);
      console.log('Set pendingControlExpansion to:', pendingControlExpansion);
      console.log('Stored section states:', pendingSectionStates);
      
      // Reset control setup flag since control will be recreated
      controlSetupDone = false;
      
      const center = map.getCenter();
      const zoom = map.getZoom();
      map.remove();
      
      // Convert zoom level to maintain similar field of view
      let targetZoom;
      if (to27700) {
        // Converting from 3857 to 27700
        // Get current resolution in meters per pixel
        const currentRes = map.options.crs.scale(zoom);
        // OSGB resolutions: [896, 448, 224, 112, 56, 28, 14, 7, 3.5, 1.75, 0.875, 0.4375, 0.21875]
        const osgbResolutions = [896, 448, 224, 112, 56, 28, 14, 7, 3.5, 1.75, 0.875, 0.4375, 0.21875];
        // Find closest matching resolution
        const webMercatorRes = 156543.03392804097 / Math.pow(2, zoom); // Web Mercator resolution at this zoom
        let bestMatch = 0;
        let bestDiff = Math.abs(osgbResolutions[0] - webMercatorRes);
        for (let i = 1; i < osgbResolutions.length; i++) {
          const diff = Math.abs(osgbResolutions[i] - webMercatorRes);
          if (diff < bestDiff) {
            bestDiff = diff;
            bestMatch = i;
          }
        }
        targetZoom = Math.max(0, Math.min(13, bestMatch));
      } else {
        // Converting from 27700 to 3857
        // Reverse: get OSGB resolution and find matching Web Mercator zoom
        const osgbResolutions = [896, 448, 224, 112, 56, 28, 14, 7, 3.5, 1.75, 0.875, 0.4375, 0.21875];
        const currentOsgbRes = osgbResolutions[Math.min(zoom, osgbResolutions.length - 1)];
        // Find matching Web Mercator zoom level
        targetZoom = Math.round(Math.log2(156543.03392804097 / currentOsgbRes));
        targetZoom = Math.max(0, Math.min(19, targetZoom));
      }
      
      const opts = to27700 ? { crs: osgb, center: center, zoom: targetZoom } : { center: center, zoom: targetZoom };
      map = L.map('map', opts);
      currentCRS = to27700 ? '27700' : '3857';
      
      // Recreate layers - layer control removed, using custom control instead
      initialiseLayers();
      
      // Re-add scale control after CRS switch
      L.control.scale({
        position: 'bottomleft',
        metric: true,
        imperial: false,
        maxWidth: 200
      }).addTo(map);

      // Re-add custom trigpointing control after CRS switch
      L.control.trigpointingControl({
        position: 'topright'
      }).addTo(map);
      
      // Add the correct layer based on user selection
      if (targetLayerName === 'OS Leisure') {
        leisureLayer.addTo(map);
      } else if (targetLayerName === 'OS Outdoor') {
        outdoorLayer.addTo(map);
      } else if (targetLayerName === 'ESRI.WorldImagery') {
        esriLayer.addTo(map);
      } else {
        osmLayer.addTo(map);
      }
      
      currentLayerName = targetLayerName;
      
      // Reattach handlers
      document.getElementById('locbtn').onclick = locate;
      map.on('baselayerchange', onBaseLayerChange);
      
      // Reset error tracking for new map
      hideErrorFeedback();
      tileErrorCount = 0;
      tileSuccessCount = 0;
      
      // Setup custom control after CRS switch
      setTimeout(() => {
        setupTrigpointingControl();
        loadControlPreferences();
        initialiseMarkers(); // Reinitialise markers after CRS switch
        
        // Update zoom level display after CRS switch
        updateZoomLevelDisplay();
        
        // Check if control state was restored properly during creation
        console.log('Checking control state after CRS switch. PendingControlExpansion:', pendingControlExpansion);
        if (pendingControlExpansion) {
          const newPanel = document.getElementById('trigpointing-panel');
          const newToggle = document.getElementById('main-toggle');
          console.log('Found new panel:', !!newPanel, 'Found new toggle:', !!newToggle);
          
          if (newPanel) {
            console.log('Panel current classes after creation:', newPanel.className);
            console.log('Panel has collapsed class:', newPanel.classList.contains('collapsed'));
            
            // Verify the control was created in expanded state
            if (!newPanel.classList.contains('collapsed')) {
              console.log('Control was correctly created in expanded state');
            } else {
              console.log('Control was not created in expanded state, forcing expansion');
              newPanel.classList.remove('collapsed');
              if (newToggle) {
                newToggle.classList.add('expanded');
              }
            }
            pendingControlExpansion = false; // Clear the flag
          } else {
            console.log('Could not find new panel element');
          }
        } else {
          console.log('Control was not expanded before CRS switch, correctly created collapsed');
        }
        
        // Restore individual section states
        console.log('Restoring section states:', pendingSectionStates);
        Object.keys(pendingSectionStates).forEach(sectionName => {
          const shouldBeExpanded = pendingSectionStates[sectionName];
          const sectionContent = document.getElementById(sectionName + '-content');
          const sectionHeader = sectionContent ? sectionContent.previousElementSibling : null;
          const toggle = sectionHeader ? sectionHeader.querySelector('.toggle-icon') : null;
          
          if (sectionContent && shouldBeExpanded) {
            console.log(`Expanding section ${sectionName}`);
            sectionContent.classList.remove('collapsed');
            if (toggle) toggle.classList.add('expanded');
          } else if (sectionContent && !shouldBeExpanded) {
            console.log(`Keeping section ${sectionName} collapsed`);
            sectionContent.classList.add('collapsed');
            if (toggle) toggle.classList.remove('expanded');
          }
        });
        
        // Clear section states
        pendingSectionStates = {};
      }, 100);
      
      switchingCRS = false;
    }

    function onBaseLayerChange(e) {
      if (switchingCRS) return; // Ignore events during CRS switching
      
      const name = e.name || '';
      currentLayerName = name;
      
      // Don't save preferences - map changes should be temporary
      // Only the Settings activity should modify user preferences
      
      const needs27700 = name.indexOf('27700') !== -1;
      const needsCRSSwitch = (needs27700 && currentCRS !== '27700') || (!needs27700 && currentCRS !== '3857');
      
      if (needsCRSSwitch) {
        switchCRS(needs27700, name);
      }
    }

    // updateLayerControlSelection function removed - no longer needed with custom control

    // Custom Trigpointing Control
    L.Control.TrigpointingControl = L.Control.extend({
      onAdd: function(map) {
        const container = L.DomUtil.create('div', 'leaflet-trigpointing-control leaflet-control');
        
        // Conditionally set initial collapsed state based on pending restoration
        const initialCollapsedClass = pendingControlExpansion ? '' : 'collapsed';
        const initialToggleClass = pendingControlExpansion ? 'expanded' : '';
        
        console.log('Creating control with pendingControlExpansion:', pendingControlExpansion);
        console.log('Initial collapsed class:', initialCollapsedClass);
        console.log('Initial toggle class:', initialToggleClass);
        
        container.innerHTML = `
          <div class="trigpointing-control-header" id="trigpointing-header">
            <span>üó∫Ô∏è Controls</span>
            <span class="toggle-icon ${initialToggleClass}" id="main-toggle">‚ñº</span>
          </div>
          <div class="trigpointing-control-panel ${initialCollapsedClass}" id="trigpointing-panel">
            
            <!-- Map Style Section -->
            <div class="control-section">
              <button class="section-header" data-section="mapstyle">
                <span>üó∫Ô∏è Map Style</span>
                <span class="toggle-icon">‚ñº</span>
              </button>
              <div class="section-content collapsed" id="mapstyle-content">
                <div class="control-option">
                  <input type="radio" name="mapstyle" value="OpenStreetMap" id="js-osm">
                  <label for="js-osm">OpenStreetMap</label>
                </div>
                <div class="control-option">
                  <input type="radio" name="mapstyle" value="ESRI.WorldImagery" id="js-esri">
                  <label for="js-esri">Satellite</label>
                </div>
                <div class="control-option">
                  <input type="radio" name="mapstyle" value="OS Outdoor" id="js-outdoor">
                  <label for="js-outdoor">OS Digital</label>
                </div>
                <div class="control-option">
                  <input type="radio" name="mapstyle" value="OS Leisure" id="js-leisure">
                  <label for="js-leisure">OS Paper</label>
                </div>
              </div>
            </div>
            
            <!-- Marker Colour Section -->
            <div class="control-section">
              <button class="section-header" data-section="markercolor">
                <span>üé® Marker Colours</span>
                <span class="toggle-icon">‚ñº</span>
              </button>
              <div class="section-content collapsed" id="markercolor-content">
                <div class="control-option">
                  <input type="radio" name="markercolor" value="condition" id="js-condition">
                  <label for="js-condition">By Condition</label>
                </div>
                <div class="control-option">
                  <input type="radio" name="markercolor" value="logged" id="js-logged">
                  <label for="js-logged">By Logged Status</label>
                </div>
                <div class="control-option">
                  <input type="radio" name="markercolor" value="none" id="js-none">
                  <label for="js-none">None (Default)</label>
                </div>
              </div>
            </div>
            
            <!-- Trigpoint Types Section -->
            <div class="control-section">
              <button class="section-header" data-section="trigpointtypes">
                <span>üèîÔ∏è Trigpoint types</span>
                <span class="toggle-icon">‚ñº</span>
              </button>
              <div class="section-content collapsed" id="trigpointtypes-content">
                <div class="control-option">
                  <input type="radio" name="trigpointtype" value="pillars" id="js-types-pillars">
                  <label for="js-types-pillars">Pillars Only</label>
                </div>
                <div class="control-option">
                  <input type="radio" name="trigpointtype" value="pillarsfbm" id="js-types-pillarsfbm">
                  <label for="js-types-pillarsfbm">Pillars + FBM</label>
                </div>
                <div class="control-option">
                  <input type="radio" name="trigpointtype" value="fbm" id="js-types-fbm">
                  <label for="js-types-fbm">FBM Only</label>
                </div>
                <div class="control-option">
                  <input type="radio" name="trigpointtype" value="passive" id="js-types-passive">
                  <label for="js-types-passive">Passive Stations</label>
                </div>
                <div class="control-option">
                  <input type="radio" name="trigpointtype" value="intersected" id="js-types-intersected">
                  <label for="js-types-intersected">Intersected Stations</label>
                </div>
                <div class="control-option">
                  <input type="radio" name="trigpointtype" value="nointersected" id="js-types-nointersected">
                  <label for="js-types-nointersected">All except Intersected</label>
                </div>
                <div class="control-option">
                  <input type="radio" name="trigpointtype" value="all" id="js-types-all">
                  <label for="js-types-all">All Types</label>
                </div>
              </div>
            </div>
            
            <!-- Filter Found Section -->
            <div class="control-section">
              <button class="section-header" data-section="filterfound">
                <span>üîç Filter found</span>
                <span class="toggle-icon">‚ñº</span>
              </button>
              <div class="section-content collapsed" id="filterfound-content">
                <div class="control-option">
                  <input type="radio" name="filterfound" value="all" id="js-found-all">
                  <label for="js-found-all">Logged or not</label>
                </div>
                <div class="control-option">
                  <input type="radio" name="filterfound" value="logged" id="js-found-logged">
                  <label for="js-found-logged">Logged</label>
                </div>
                <div class="control-option">
                  <input type="radio" name="filterfound" value="notlogged" id="js-found-notlogged">
                  <label for="js-found-notlogged">Not Logged</label>
                </div>
                <div class="control-option">
                  <input type="radio" name="filterfound" value="marked" id="js-found-marked">
                  <label for="js-found-marked">Marked</label>
                </div>
                <div class="control-option">
                  <input type="radio" name="filterfound" value="unsynced" id="js-found-unsynced">
                  <label for="js-found-unsynced">Unsynced</label>
                </div>
              </div>
            </div>
            
          </div>
        `;
        
        // Prevent map interaction when clicking on control
        L.DomEvent.disableClickPropagation(container);
        L.DomEvent.disableScrollPropagation(container);
        
        return container;
      },
      
      onRemove: function(map) {
        // Cleanup if needed
      }
    });

    // Factory function
    L.control.trigpointingControl = function(opts) {
      return new L.Control.TrigpointingControl(opts);
    };

    // Control interaction handlers
    let controlSetupDone = false;
    function setupTrigpointingControl() {
      // Prevent duplicate event listener setup
      if (controlSetupDone) {
        console.log('Control setup already done, skipping duplicate setup');
        return;
      }
      
      // Main panel toggle
      document.getElementById('trigpointing-header').addEventListener('click', function() {
        const panel = document.getElementById('trigpointing-panel');
        const toggle = document.getElementById('main-toggle');
        
        panel.classList.toggle('collapsed');
        toggle.classList.toggle('expanded');
      });
      
      // Section toggles
      document.querySelectorAll('.section-header').forEach(header => {
        header.addEventListener('click', function() {
          const section = this.getAttribute('data-section');
          const content = document.getElementById(section + '-content');
          const toggle = this.querySelector('.toggle-icon');
          
          content.classList.toggle('collapsed');
          toggle.classList.toggle('expanded');
        });
      });
      
      controlSetupDone = true;
      
      // Check for pending control expansion (backup restoration)
      if (pendingControlExpansion) {
        console.log('Backup restoration: Checking if expansion needed');
        const panel = document.getElementById('trigpointing-panel');
        const toggle = document.getElementById('main-toggle');
        if (panel && panel.classList.contains('collapsed')) {
          console.log('Backup restoration: Panel still collapsed, forcing expansion');
          panel.classList.remove('collapsed');
          if (toggle) toggle.classList.add('expanded');
          console.log('Backup restoration: Control expanded successfully');
        } else {
          console.log('Backup restoration: Panel already expanded or not found');
        }
        pendingControlExpansion = false;
      }
      
      // Backup restoration for section states
      if (Object.keys(pendingSectionStates).length > 0) {
        console.log('Backup restoration: Restoring section states:', pendingSectionStates);
        Object.keys(pendingSectionStates).forEach(sectionName => {
          const shouldBeExpanded = pendingSectionStates[sectionName];
          const sectionContent = document.getElementById(sectionName + '-content');
          const sectionHeader = sectionContent ? sectionContent.previousElementSibling : null;
          const toggle = sectionHeader ? sectionHeader.querySelector('.toggle-icon') : null;
          
          if (sectionContent && shouldBeExpanded && sectionContent.classList.contains('collapsed')) {
            console.log(`Backup restoration: Expanding section ${sectionName}`);
            sectionContent.classList.remove('collapsed');
            if (toggle) toggle.classList.add('expanded');
          }
        });
        pendingSectionStates = {};
      }
      
      // Radio button handlers
      document.querySelectorAll('input[name="mapstyle"]').forEach(radio => {
        radio.addEventListener('change', function() {
          if (this.checked) {
            console.log('JS Control - Map style changed to:', this.value);
            // Switch map layer immediately
            switchMapToLayer(this.value);
          }
        });
      });
      
      document.querySelectorAll('input[name="markercolor"]').forEach(radio => {
        radio.addEventListener('change', function() {
          if (this.checked) {
            console.log('JS Control - Marker colour changed to:', this.value);
            currentMarkerColor = this.value;
            localStorage.setItem('leaflet_marker_color', this.value);
            if (markersLayer) {
              currentBounds = null; // Force reload
              loadTrigpointMarkers();
            }
          }
        });
      });
      
      // Trigpoint type controls
      document.querySelectorAll('input[name="trigpointtype"]').forEach(radio => {
        radio.addEventListener('change', function() {
          if (this.checked) {
            console.log('JS Control - Trigpoint type changed to:', this.value);
            currentTrigpointType = this.value;
            localStorage.setItem('leaflet_trigpoint_type', this.value);
            
            // Save to Android preferences for persistence across pages
            try {
              if (typeof AndroidPrefs !== 'undefined' && AndroidPrefs.saveTrigpointTypePreference) {
                AndroidPrefs.saveTrigpointTypePreference(this.value);
                console.log('Saved trigpoint type to Android preferences:', this.value);
              }
            } catch (e) {
              console.log('Failed to save trigpoint type to Android preferences:', e);
            }
            
            if (markersLayer) {
              currentBounds = null; // Force reload
              loadTrigpointMarkers();
            }
          }
        });
      });
      
      // Filter found controls
      document.querySelectorAll('input[name="filterfound"]').forEach(radio => {
        radio.addEventListener('change', function() {
          if (this.checked) {
            console.log('JS Control - Filter found changed to:', this.value);
            currentFilterFound = this.value;
            localStorage.setItem('leaflet_filter_found', this.value);
            
            // Save to Android preferences for persistence across pages
            try {
              if (typeof AndroidPrefs !== 'undefined' && AndroidPrefs.saveFilterFoundPreference) {
                AndroidPrefs.saveFilterFoundPreference(this.value);
                console.log('Saved filter found to Android preferences:', this.value);
              }
            } catch (e) {
              console.log('Failed to save filter found to Android preferences:', e);
            }
            
            if (markersLayer) {
              currentBounds = null; // Force reload
              loadTrigpointMarkers();
            }
          }
        });
      });
    }

    // Convert Android preference values to JavaScript layer names
    function convertPreferenceToJSLayer(preferenceValue) {
      switch (preferenceValue) {
        case 'ESRI.WorldImagery': return 'ESRI.WorldImagery';
        case 'OS Outdoor (3857)': return 'OS Outdoor';
        case 'OS Leisure (27700)': return 'OS Leisure';
        case 'OpenStreetMap': return 'OpenStreetMap';
        default: return 'OpenStreetMap';
      }
    }

    // Convert JavaScript layer names back to preference values
    function convertJSLayerToPreference(jsLayerName) {
      switch (jsLayerName) {
        case 'ESRI.WorldImagery': return 'ESRI.WorldImagery';
        case 'OS Outdoor': return 'OS Outdoor (3857)';
        case 'OS Leisure': return 'OS Leisure (27700)';
        case 'OpenStreetMap': return 'OpenStreetMap';
        default: return 'OpenStreetMap';
      }
    }

    // Functions that will be called from Android
    function switchToLayer(layerName) {
      console.log('Switching to layer:', layerName);
      
      // Convert Android preference value to JavaScript layer name
      const jsLayerName = convertPreferenceToJSLayer(layerName);
      console.log('Converted layer name:', jsLayerName);
      
      // Update the JavaScript control radio buttons
      document.querySelectorAll('input[name="mapstyle"]').forEach(radio => {
        radio.checked = (radio.value === jsLayerName);
      });
      
      // Actually switch the map layer using the converted name
      switchMapToLayer(jsLayerName);
    }

    function switchMapToLayer(layerName) {
      // Save the current layer choice to session storage (for temporary changes)
      const preferenceValue = convertJSLayerToPreference(layerName);
      sessionStorage.setItem('leaflet_session_map_style', preferenceValue);
      console.log('Saved session map style:', preferenceValue);
      
      // Check if we need CRS switch
      const currentIs27700 = (currentCRS === '27700');
      const targetIs27700 = (layerName === 'OS Leisure');
      
      if (currentIs27700 !== targetIs27700) {
        // Need CRS switch - use existing mechanism
        switchCRS(targetIs27700, layerName);
        return;
      }
      
      // Same CRS - just switch layers directly
      console.log('Switching layers within same CRS from', currentLayerName, 'to', layerName);
      
      // Remove current layer
      if (currentLayerName === 'OpenStreetMap' && map.hasLayer(osmLayer)) {
        map.removeLayer(osmLayer);
      } else if (currentLayerName === 'ESRI.WorldImagery' && map.hasLayer(esriLayer)) {
        map.removeLayer(esriLayer);
      } else if (currentLayerName === 'OS Outdoor' && map.hasLayer(outdoorLayer)) {
        map.removeLayer(outdoorLayer);
      } else if (currentLayerName === 'OS Leisure' && map.hasLayer(leisureLayer)) {
        map.removeLayer(leisureLayer);
      }
      
      // Add new layer
      if (layerName === 'OpenStreetMap') {
        osmLayer.addTo(map);
      } else if (layerName === 'ESRI.WorldImagery') {
        esriLayer.addTo(map);
      } else if (layerName === 'OS Outdoor') {
        outdoorLayer.addTo(map);
      } else if (layerName === 'OS Leisure') {
        leisureLayer.addTo(map);
      }
      
      // Update current layer name
      currentLayerName = layerName;
      
      // No need to trigger preference saving - map changes are temporary
    }

    function updateMarkerColors(colorScheme) {
      console.log('Updating marker colours:', colorScheme);
      
      // Update the JavaScript control radio buttons
      document.querySelectorAll('input[name="markercolor"]').forEach(radio => {
        radio.checked = (radio.value === colorScheme);
      });
      
      // Update current marker colour and reload markers
      currentMarkerColor = colorScheme;
      localStorage.setItem('leaflet_marker_color', colorScheme);
      if (markersLayer) {
        currentBounds = null; // Force reload
        loadTrigpointMarkers();
      }
    }

    function updateTrigpointType(type) {
      console.log('Updating trigpoint type:', type);
      
      // Update the JavaScript control radio buttons if they exist
      document.querySelectorAll('input[name="trigpointtype"]').forEach(radio => {
        radio.checked = (radio.value === type);
      });
      
      // Update current type and reload markers
      currentTrigpointType = type;
      localStorage.setItem('leaflet_trigpoint_type', type);
      if (markersLayer) {
        currentBounds = null; // Force reload
        loadTrigpointMarkers();
      }
    }
    
    function updateFilterFound(found) {
      console.log('Updating filter found:', found);
      
      // Update the JavaScript control radio buttons if they exist
      document.querySelectorAll('input[name="filterfound"]').forEach(radio => {
        radio.checked = (radio.value === found);
      });
      
      // Update current found filter and reload markers
      currentFilterFound = found;
      localStorage.setItem('leaflet_filter_found', found);
      if (markersLayer) {
        currentBounds = null; // Force reload
        loadTrigpointMarkers();
      }
    }

    // Load preferences and set initial control states
    function loadControlPreferences() {
      // Set map style selection
      const currentMapStyle = currentLayerName || 'OpenStreetMap';
      document.querySelectorAll('input[name="mapstyle"]').forEach(radio => {
        radio.checked = (radio.value === currentMapStyle);
      });
      
      // Set other preferences from localStorage or defaults and update globals
      const markerColor = localStorage.getItem('leaflet_marker_color') || 'none';
      currentMarkerColor = markerColor;
      document.querySelectorAll('input[name="markercolor"]').forEach(radio => {
        radio.checked = (radio.value === markerColor);
      });
      
      // Try to get trigpoint type preference from Android first, fallback to localStorage
      let trigpointType = 'all';
      try {
        if (typeof AndroidPrefs !== 'undefined' && AndroidPrefs.getTrigpointTypePreference) {
          trigpointType = AndroidPrefs.getTrigpointTypePreference();
          console.log('Loaded trigpoint type from Android:', trigpointType);
        } else {
          trigpointType = localStorage.getItem('leaflet_trigpoint_type') || 'all';
          console.log('Loaded trigpoint type from localStorage:', trigpointType);
        }
      } catch (e) {
        console.log('Failed to get trigpoint type from Android, using default:', e);
        trigpointType = localStorage.getItem('leaflet_trigpoint_type') || 'all';
      }
      
      currentTrigpointType = trigpointType;
      document.querySelectorAll('input[name="trigpointtype"]').forEach(radio => {
        radio.checked = (radio.value === trigpointType);
      });
      
      // Try to get filter preference from Android first, fallback to localStorage
      let filterFound = 'all';
      try {
        if (typeof AndroidPrefs !== 'undefined' && AndroidPrefs.getFilterFoundPreference) {
          filterFound = AndroidPrefs.getFilterFoundPreference();
        } else {
          filterFound = localStorage.getItem('leaflet_filter_found') || 'all';
        }
      } catch (e) {
        console.log('Could not get Android preference, using localStorage:', e);
        filterFound = localStorage.getItem('leaflet_filter_found') || 'all';
      }
      
      currentFilterFound = filterFound;
      document.querySelectorAll('input[name="filterfound"]').forEach(radio => {
        radio.checked = (radio.value === filterFound);
      });
      
      // Sync localStorage with Android preference
      localStorage.setItem('leaflet_filter_found', filterFound);
    }

    // Trigpoint marker management
    let markersLayer = null;
    let currentBounds = null;
    let currentMarkerColor = 'none';
    let currentTrigpointType = 'all';
    let currentFilterFound = 'all';

    // Service Worker communication
    async function sendServiceWorkerMessage(type, data = {}) {
      console.log('SW MESSAGE: Attempting to send message type:', type);
      
      if (!navigator.serviceWorker) {
        console.error('SW MESSAGE: Service Worker not supported');
        throw new Error('Service Worker not supported');
      }
      
      // Wait for service worker to be ready
      await navigator.serviceWorker.ready;
      
      if (!navigator.serviceWorker.controller) {
        console.error('SW MESSAGE: Service Worker controller not available');
        throw new Error('Service Worker not controlling page - try refreshing');
      }
      
      console.log('SW MESSAGE: Service Worker ready, sending message');
      
      return new Promise((resolve, reject) => {
        const messageChannel = new MessageChannel();
        
        messageChannel.port1.onmessage = (event) => {
          console.log('SW MESSAGE: Received response:', event.data);
          if (event.data.success) {
            resolve(event.data);
          } else {
            reject(new Error(event.data.error));
          }
        };
        
        navigator.serviceWorker.controller.postMessage(
          { type, data },
          [messageChannel.port2]
        );
      });
    }

    /*
    // Cache management functions
    async function getCacheStatus() {
      console.log('CACHE: Getting cache status, mode:', cacheMode);
      
      if (cacheMode === 'serviceworker') {
        try {
          const response = await sendServiceWorkerMessage('CACHE_STATUS');
          return response.status;
        } catch (error) {
          console.error('CACHE: Service Worker cache status failed:', error);
          return { error: 'Service Worker error: ' + error.message };
        }
      } else if (cacheMode === 'webview') {
        // WebView fallback - estimate cache from localStorage and performance
        const initTime = localStorage.getItem('cache_init_time');
        const estimatedTiles = localStorage.getItem('cached_tiles_count') || '0';
        const daysSinceInit = initTime ? Math.floor((Date.now() - parseInt(initTime)) / (1000 * 60 * 60 * 24)) : 0;
        
        return {
          mode: 'WebView Cache',
          tileCount: parseInt(estimatedTiles),
          totalSize: parseInt(estimatedTiles) * 15000, // Estimate 15KB per tile
          usagePercent: Math.min(Math.floor(parseInt(estimatedTiles) / 100), 100), // Estimate %
          cacheAge: daysSinceInit + ' days',
          note: 'Using WebView built-in cache (tiles persist until app cache cleared)'
        };
      } else {
        return { error: 'Cache not available' };
      }
    }

    async function clearTileCache() {
      console.log('CACHE: Clearing cache, mode:', cacheMode);
      
      if (cacheMode === 'serviceworker') {
        try {
          await sendServiceWorkerMessage('CLEAR_CACHE');
          console.log('CACHE: Service Worker cache cleared');
          return true;
        } catch (error) {
          console.error('CACHE: Failed to clear SW cache:', error);
          return false;
        }
      } else if (cacheMode === 'webview') {
        // WebView fallback - clear localStorage and prompt for app cache clear
        localStorage.setItem('cached_tiles_count', '0');
        localStorage.setItem('cache_init_time', Date.now().toString());
        console.log('CACHE: WebView cache metadata cleared');
        
        // Note: Can't programmatically clear WebView cache from JavaScript
        // This requires Android code or user action
        return { 
          partial: true, 
          message: 'Cache metadata cleared. To fully clear tiles, go to Android Settings > Apps > TrigpointingUK > Storage > Clear Cache' 
        };
      } else {
        return false;
      }
    }

    async function downloadBulkTiles(zipUrl, options = {}) {
      console.log('CACHE: Bulk download request, mode:', cacheMode);
      
      if (cacheMode === 'serviceworker') {
        try {
          const response = await sendServiceWorkerMessage('BULK_DOWNLOAD', { 
            url: zipUrl, 
            options 
          });
          console.log('CACHE: Service Worker bulk download completed');
          return response.result;
        } catch (error) {
          console.error('CACHE: Bulk download failed:', error);
          throw error;
        }
      } else if (cacheMode === 'webview') {
        // WebView fallback - can't directly bulk download to WebView cache
        // But we can pre-load tiles by making requests
        throw new Error('Bulk download not supported in WebView mode. Tiles will cache automatically as you browse the map.');
      } else {
        throw new Error('Cache not available');
      }
    }
    */

    function initialiseMarkers() {
      console.log('MARKER DEBUG: initialiseMarkers() called');
      console.log('MARKER DEBUG: Current CRS:', currentCRS);
      console.log('MARKER DEBUG: Map exists:', !!map);
      
      // Create markers layer group
      markersLayer = L.layerGroup().addTo(map);
      console.log('MARKER DEBUG: Created markersLayer and added to map');
      
      // Load initial markers
      loadTrigpointMarkers();
      
      // Update markers when map moves
      map.on('moveend', () => {
        loadTrigpointMarkers();
      });
      
      map.on('zoomend', () => {
        loadTrigpointMarkers();
        updateZoomLevelDisplay();
      });
    }

    function loadTrigpointMarkers() {
      console.log('MARKER DEBUG: loadTrigpointMarkers() called');
      console.log('MARKER DEBUG: markersLayer exists:', !!markersLayer);
      
      const bounds = map.getBounds();
      const zoom = map.getZoom();
      
      // Marker count is now user-configurable, so no need for zoom-based clearing
      
      // Check if we need to reload (bounds changed significantly)
      if (currentBounds && bounds.contains(currentBounds)) {
        console.log('Markers: No reload needed, current view within cached bounds');
        return;
      }
      
      console.log('Loading trigpoint markers for bounds:', bounds);
      console.log(`Map CRS: ${currentCRS}, Zoom: ${map.getZoom()}`);
      
      // Expand bounds for efficient loading
      const expandedBounds = bounds.pad(0.5); // 50% expansion
      currentBounds = expandedBounds;
      
      console.log(`Querying trigpoints: S=${expandedBounds.getSouth()}, W=${expandedBounds.getWest()}, N=${expandedBounds.getNorth()}, E=${expandedBounds.getEast()}`);
      
      // Call Android to get trigpoint data
      AndroidPrefs.getTrigpointData(
        expandedBounds.getSouth(),
        expandedBounds.getWest(), 
        expandedBounds.getNorth(),
        expandedBounds.getEast(),
        currentTrigpointType,
        currentFilterFound,
        currentMarkerColor
      );
    }

    function displayTrigpointMarkers(trigpointsJson) {
      console.log('Displaying trigpoint markers:', trigpointsJson);
      
      try {
        const trigpoints = JSON.parse(trigpointsJson);
        
        // Clear existing markers
        markersLayer.clearLayers();
        
        trigpoints.forEach(trig => {
          // Use standard lat/lon - Leaflet CRS should handle transformation automatically
          const coords = [trig.lat, trig.lon];
          
          console.log(`Creating marker for ${trig.name} at [${trig.lat}, ${trig.lon}] in CRS: ${currentCRS}`);
          console.log(`Current map bounds:`, map.getBounds());
          console.log(`Map centre:`, map.getCenter());
          
          const marker = L.marker(coords, {
            icon: createTrigIcon(trig)
          });
          
          // Add popup with basic info
          marker.bindPopup(`
            <b>${trig.name}</b><br>
            Type: ${trig.type}<br>
            Condition: ${trig.condition}<br>
            <a href="#" onclick="AndroidPrefs.openTrigDetails(${trig.id})">View Details</a>
          `);
          
          // Add click handler for details
          marker.on('click', () => {
            AndroidPrefs.openTrigDetails(trig.id);
          });
          
          markersLayer.addLayer(marker);
        });
        
        console.log(`Added ${trigpoints.length} markers to map`);
        
      } catch (error) {
        console.error('Error parsing trigpoint data:', error);
      }
    }

    function getIconSizeFromStyle(iconStyle) {
      // Map icon style preferences to actual pixel sizes
      const sizeMap = {
        'small': 20,
        'medium': 50,
        'large': 80,
        'symbols': 50
      };
      
      return sizeMap[iconStyle] || 50; // Default to medium size
    }

    function createTrigIcon(trig) {
      // Determine icon based on type and coloring scheme
      let iconClass = 'trig-icon';
      let color = 'green'; // default
      
      // Apply coloring scheme
      if (currentMarkerColor === 'condition') {
        color = getConditionColor(trig.condition);
      } else if (currentMarkerColor === 'logged') {
        color = getLoggedColor(trig.logged);
      }
      
      // Get icon style and size from Android preferences
      const iconStyle = AndroidPrefs.getIconStyle();
      const iconSize = getIconSizeFromStyle(iconStyle);
      
      // Get type-specific icon
      const iconUrl = getTrigIconUrl(trig.type, color, trig.flagged, iconStyle);
      console.log(`Creating icon for ${trig.name}: type=${trig.type}, colour=${color}, style=${iconStyle}, size=${iconSize}px, iconUrl=${iconUrl}`);
      
      return L.icon({
        iconUrl: iconUrl,
        iconSize: [iconSize, iconSize],
        iconAnchor: [iconSize/2, iconSize/2],
        popupAnchor: [0, -iconSize/2]
      });
    }

    function getConditionColor(condition) {
      // Match OSMdroid MapIcon colour logic using single-letter codes
      switch (condition) {
        case 'U': // Unknown
        case 'Z': // Condition not logged 
        case '-': // Trig not logged
          return 'grey';
        case 'G': // Good
        case 'S': // Slightly damaged
        case 'C': // Converted
        case 'D': // Damaged
        case 'T': // Toppled
        case 'M': // Moved
        case 'R': // Remains
          return 'green';
        case 'V': // Visible (unreachable but visible)
          return 'yellow';
        case 'Q': // Possibly missing
        case 'X': // Missing/destroyed
        case 'P': // Inaccessible
        case 'N': // Couldn't find
          return 'red';
        default:
          return 'grey';
      }
    }

    function getLoggedColor(logged) {
      // Use logged status codes
      if (logged === '-') { // TRIGNOTLOGGED
        return 'grey';
      } else {
        return 'green';
      }
    }

    function getTrigIconUrl(type, color, flagged, iconStyle) {
      // Check if using trigpoint symbols
      if (iconStyle === 'symbols') {
        // Map database type codes to symbol icon names
        const typeMap = {
          'PI': 'pillar',
          'FB': 'fbm', 
          'IN': 'intersected'
        };
        
        // Default to passive for any unknown types
        const iconType = typeMap[type] || 'passive';
        
        // Use new symbol icons with full color support
        const highlight = flagged ? '_h' : '';
        const iconName = `symbolicon_${iconType}_${color}${highlight}.png`;
        
        return `icons/${iconName}`;
      } else if (iconStyle === 'types') {
        // Type Icons - same color/highlighting logic as Small/Medium/Large
        // Map database type codes to icon names
        const typeMap = {
          'PI': 'pillar',
          'FB': 'fbm', 
          'IN': 'intersected'
        };
        
        // Default to passive for any unknown types
        const iconType = typeMap[type] || 'passive';
        
        // Use new type icons with full color support
        const highlight = flagged ? '_h' : '';
        const iconName = `typeicon_${iconType}_${color}${highlight}.png`;
        
        return `icons/${iconName}`;
      } else {
        // Use coloured logo icons (existing system)
        // Map database type codes to icon type names
        const typeMap = {
          'PI': 'pillar',
          'FB': 'fbm', 
          'IN': 'intersected'
        };
        
        // Default to passive for any unknown types
        const iconType = typeMap[type] || 'passive';
        
        // Build icon path based on type, colour, and highlight state
        const highlight = flagged ? '_h' : '';
        const iconName = `mapicon_${iconType}_${color}${highlight}.png`;
        
        // Use relative path from current leaflet directory
        return `icons/${iconName}`;
      }
    }

    // Update zoom level display
    function updateZoomLevelDisplay() {
      const currentZoom = Math.round(map.getZoom());
      const zoomDisplay = document.getElementById('zoom-level-display');
      if (zoomDisplay) {
        zoomDisplay.textContent = currentZoom;
      }
    }

    initialiseMap();

    function autoLocateOnFirstVisit() {
      // Check if we should auto-centre on first visit
      const hasAutoLocated = sessionStorage.getItem('leaflet_auto_located');
      if (!hasAutoLocated) {
        console.log('First visit to map - starting location tracking by default');
        sessionStorage.setItem('leaflet_auto_located', 'true');
        
        // Start location tracking automatically on first visit
        locate();
      }
    }

    // Global variables for location tracking
    let locationMarker = null;
    let accuracyCircle = null;
    let watchId = null;
    let isTrackingLocation = false;

    function locate(){
      if (!navigator.geolocation) { 
        console.log('Geolocation not supported'); 
        return; 
      }
      
      if (isTrackingLocation) {
        // Stop tracking and remove location marker
        stopLocationTracking();
        return;
      }
      
      console.log('Starting location tracking...');
      isTrackingLocation = true;
      
      // Update button appearance to show tracking state
      const locBtn = document.getElementById('locbtn');
      locBtn.style.backgroundColor = '#4285f4';
      locBtn.style.color = 'white';
      locBtn.title = 'Stop tracking location';
      
      // Start watching position
      watchId = navigator.geolocation.watchPosition(function(pos){
        const lat = pos.coords.latitude;
        const lon = pos.coords.longitude;
        const accuracy = pos.coords.accuracy;
        const heading = pos.coords.heading;
        
        console.log(`Location update: ${lat}, ${lon}, accuracy: ${accuracy}m, heading: ${heading !== null ? heading + '¬∞' : 'not available'}`);
        
        // Cache this location for future map initializations
        const locationData = {
          lat: lat,
          lon: lon,
          timestamp: Date.now()
        };
        localStorage.setItem('leaflet_last_location', JSON.stringify(locationData));
        
        // Update or create location marker
        const isFirstLocationFix = !locationMarker;
        updateLocationMarker(lat, lon, accuracy, heading);
        
        // Center map and set appropriate zoom on first location fix
        if (isFirstLocationFix) {
          centerMapOnLocation(lat, lon);
        }
        
      }, function(err){
        console.log('Error getting location: ' + err.message);
        stopLocationTracking();
        // Don't show alert for auto-location failures to avoid disrupting UX
      }, {
        enableHighAccuracy: true,
        timeout: 15000,
        maximumAge: 60000 // 1 minute
      });
    }

    function stopLocationTracking() {
      if (watchId !== null) {
        navigator.geolocation.clearWatch(watchId);
        watchId = null;
      }
      
      isTrackingLocation = false;
      
      // Reset button appearance
      const locBtn = document.getElementById('locbtn');
      locBtn.style.backgroundColor = '';
      locBtn.style.color = '';
      locBtn.title = 'My location';
      
      // Remove location marker and accuracy circle
      if (locationMarker) {
        map.removeLayer(locationMarker);
        locationMarker = null;
      }
      if (accuracyCircle) {
        map.removeLayer(accuracyCircle);
        accuracyCircle = null;
      }
      
      console.log('Stopped location tracking');
    }

    function centerMapOnLocation(lat, lon) {
      // Smart zoom: use zoom 13 equivalent unless user is already zoomed in closer
      let targetZoom;
      if (currentCRS === '27700') {
        // EPSG:27700 equivalent of zoom 13 in Web Mercator
        targetZoom = 6;
      } else {
        // EPSG:3857 Web Mercator
        targetZoom = 13;
      }
      
      // Only change zoom if current zoom is less than target (zoomed out more)
      const currentZoom = map.getZoom();
      const finalZoom = currentZoom < targetZoom ? targetZoom : currentZoom;
      
      console.log(`Centering on location with zoom ${finalZoom} (current: ${currentZoom}, target: ${targetZoom}) for CRS ${currentCRS}`);
      map.setView([lat, lon], finalZoom);
    }

    function updateLocationMarker(lat, lon, accuracy, heading) {
      // Remove existing marker and circle
      if (locationMarker) {
        map.removeLayer(locationMarker);
      }
      if (accuracyCircle) {
        map.removeLayer(accuracyCircle);
      }
      
      // Create accuracy circle
      accuracyCircle = L.circle([lat, lon], {
        radius: accuracy,
        fillColor: '#4285f4',
        fillOpacity: 0.1,
        color: '#4285f4',
        opacity: 0.3,
        weight: 1
      }).addTo(map);
      
      // Create location marker with arrow pointing in device direction
      const arrowIcon = createLocationArrowIcon(heading);
      locationMarker = L.marker([lat, lon], {
        icon: arrowIcon,
        zIndexOffset: 1000 // Ensure it appears above other markers
      }).addTo(map);
    }

    function createLocationArrowIcon(heading) {
      // Create a custom icon with an arrow pointing in the direction the device is facing
      // If heading is not available, default to pointing north (0 degrees)
      const rotation = heading !== null && heading !== undefined ? heading : 0;
      
      const iconHtml = `
        <div style="
          width: 20px; 
          height: 20px; 
          background: rgba(66, 133, 244, 0.9); 
          border: 3px solid rgba(255, 255, 255, 0.75); 
          border-radius: 50%; 
          position: relative;
          box-shadow: 0 2px 6px rgba(0,0,0,0.4);
          transform: rotate(${rotation}deg);
        ">
          <div style="
            position: absolute;
            top: -8px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-bottom: 12px solid rgba(66, 133, 244, 0.9);
          "></div>
        </div>
      `;
      
      return L.divIcon({
        html: iconHtml,
        className: 'location-marker',
        iconSize: [20, 20],
        iconAnchor: [10, 10]
      });
    }
    document.getElementById('locbtn').onclick = locate;
  </script>
</body>
</html>


